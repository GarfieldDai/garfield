{"meta":{"title":"Garfield Dai","subtitle":null,"description":null,"author":"Garfield Dai","url":"http://garfieldwiki.com"},"pages":[{"title":"关于我","date":"2019-03-24T02:03:36.702Z","updated":"2019-03-24T02:03:36.702Z","comments":true,"path":"about/index.html","permalink":"http://garfieldwiki.com/about/index.html","excerpt":"","text":"本博客主要记录本人的学习经历，目的是和大家一起分享技术心得，所有内容均为原创博客。声明：转发本博客内容请注明来源并附上链接。 如果您发现博客中有任何问题，欢迎指正。E-mail: **dai.hai@foxmail.com** 如果觉得博客内容写的不错就请我喝一杯咖啡作为鼓励吧~"},{"title":"Tags","date":"2019-03-24T02:03:36.832Z","updated":"2019-03-24T02:03:36.832Z","comments":true,"path":"tags/index.html","permalink":"http://garfieldwiki.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-03-24T02:03:36.703Z","updated":"2019-03-24T02:03:36.703Z","comments":true,"path":"categories/index.html","permalink":"http://garfieldwiki.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"使用OpenCV进行人脸检测","slug":"face-detection","date":"2018-02-08T09:54:15.000Z","updated":"2019-03-24T02:03:36.682Z","comments":true,"path":"2018/02/08/face-detection/","link":"","permalink":"http://garfieldwiki.com/2018/02/08/face-detection/","excerpt":"目的不需要高深的理论，搭建属于自己的人脸检测。","text":"目的不需要高深的理论，搭建属于自己的人脸检测。 简介人脸检测（Face Detection）属于计算机视觉（Computer Vision）的范畴，与人脸识别（Face Recognition）不一样，人脸检测只是检测是否有人脸，不能分辨具体某个人是谁。 内容需要安装以下两个环境： Python 3+ OpenCV OpenCV提供了2种已经训练好的分类器（Classifier）来进行人脸检测，分类器是由成百上千个人脸和非人脸图片训练出来的。 Haar Classifier：haarcascade_frontalface_alt.xml LBP Classifier：lbpcascade_frontalface.xml 这两个分类器都是使用灰度图（gray scales）进行训练的，因为颜色对于识别人脸来说没有什么意义，这两个分类器在目录opencv/data/下面。 两种分类器的优缺点： 代码12345678910111213141516171819# 加载OpenCV类库import cv2# 读取图片picture = cv2.imread('data/man.jpeg')# 将彩色图片转换为灰度图gray_img = cv2.cvtColor(picture, cv2.COLOR_BGR2GRAY)# 加载分类器haar_face_cascade = cv2.CascadeClassifier('data/haarcascade_frontalface_alt.xml')# lbp_face_cascade = cv2.CascadeClassifier('data/lbpcascade_frontalface.xml') # 执行人脸检测faces = haar_face_cascade.detectMultiScale(gray_img, scaleFactor=1.1, minNeighbors=5)print('Faces found: ', len(faces))# 标记检测到的人脸位置for (x, y, w, h) in faces: cv2.rectangle(picture, (x, y), (x + w, y + h), (0, 255, 0), 2)# 显示图片cv2.imshow('Test Imag', picture)cv2.waitKey(0) 参考资料OpenCV face detectionOpenCV Tutorial","categories":[{"name":"Computer Vision","slug":"Computer-Vision","permalink":"http://garfieldwiki.com/categories/Computer-Vision/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://garfieldwiki.com/tags/OpenCV/"}]},{"title":"K-means聚类算法","slug":"kMeans","date":"2017-12-18T10:18:35.000Z","updated":"2019-03-24T02:03:36.689Z","comments":true,"path":"2017/12/18/kMeans/","link":"","permalink":"http://garfieldwiki.com/2017/12/18/kMeans/","excerpt":"目的简述如何使用scikit-learnK-均值（K-means）聚类算法。","text":"目的简述如何使用scikit-learnK-均值（K-means）聚类算法。 简介K-均值聚类算法属于无监督学习，K指的是用户指定要创建的聚类（cluster）的数目。 聚类和分类最大的区别在于分类的目标已知，而聚类的目标未知，没有预先定义，聚类也被称为无监督分类（unsupervised classification）。 这里使用mglearn进行数据展示，该模块是基于matplotlib进行封装的，可以使用pip进行安装。1$ pip install mglearn 内容12345678910111213141516171819202122from sklearn.datasets import make_blobsfrom sklearn.cluster import KMeansimport mglearn as mglearn# 准备数据X, y = make_blobs(random_state=1)# 构建聚类模型，设置k值为3kmeans = KMeans(n_clusters=3)# 将数据放入模型中kmeans.fit(X)# 输出分类后的标记结果print(\"标记分类结果:\\n&#123;&#125;\".format(kmeans.labels_))# 使用散点图展示数据结果mglearn.discrete_scatter(X[:, 0], X[:, 1], kmeans.labels_, markers='o')# 显示聚类结果中心点mglearn.discrete_scatter( kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], [0, 1, 2], markers='^', markeredgewidth=2)# 根据当前模型来预测未知测试数据# print(kmeans.predict(X_test)) 参考资料K-meansmglearn homepage","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://garfieldwiki.com/categories/Machine-Learning/"}],"tags":[]},{"title":"什么是机器学习","slug":"machinelearning","date":"2017-12-09T14:41:12.000Z","updated":"2019-03-24T02:03:36.691Z","comments":true,"path":"2017/12/09/machinelearning/","link":"","permalink":"http://garfieldwiki.com/2017/12/09/machinelearning/","excerpt":"目的简述机器学习相关的概念和常用的工具使用。","text":"目的简述机器学习相关的概念和常用的工具使用。 什么是机器学习机器学习简单的讲就是从数据中提取知识。生活中有很多应用的场景，比如应用中的电影、商品、音乐推荐等可利用机器学习提取用户历史行为信息来推测用户潜在的需求，进而进行个性化推荐服务和商品。 机器学习是一门交叉学科，入门机器学习除了计算机编程基础外，还需要有一定的数学基础如高等数学，线性代数和概率论统计。 机器学习基本概念机器学习分为监督学习（supervised Learning）和无监督学习（unsupervised Learning）。 监督学习监督学习有两种：分类（classification）和回归（regression），这类算法必须知道预测什么。区别是分类还是回归，主要看结果是连续的还是离散的。比如真与假、动物分类集合{爬行类，哺乳类，鱼类，两栖类，鱼类}等一个有限的集合或者离散值，那么就是分类。如果结果是从无限的数值集合中取值如工资6383.34、2345.12、7569.321等连续值，就是回归。 我们准备做一个专家系统，这个系统是识别鸟类的系统。现在我们手中有不同的鸟类的数据，这些数据按照属性(attribute)可以归类为体重，翼展长度，是否有脚蹼和后背颜色等，这些属性也叫做特征(feature)。现在我们使用机器学习的分类来实现这个专家系统。我们需要准备两组数据，这些数据我们称为样本（sample），一组是训练数据（training data or training set)，另一组是测试数据（test data or test set）。训练数据是为了构建机器学习模型，测试数据是为了校验训练出来的模型工作的如何。 无监督学习无监督学习有两种：聚类（clustering），密度评估(density estimation)，这类算法不知道要预测什么。将数据集合分成由类似的对象组成的多个类的过程被称为聚类。将寻找描述数据统计值的过程称之为密度评估。 机器学习开发工具 Python：推荐使用Python3进行机器学习开发。 Jupyter Notebook：网页版开发编辑器。 NumPy：提供强大的N维数组对象。 SciPy：进行科学计算的基础工具包。 Matplotlib：提供了很多图表控件，方便进行数据可视化。 Pandas：提供了高性能的，简单易用的数据结构和数据分析工具。 Scikit-learn：机器学习算法的实现。 可以使用Anaconda一站式安装配置。或者安装好Python3后，使用pip进行安装。在安装之前，可以使用Python 虚拟环境，创建一个独立干净的开发环境。1$ pip install jupyter numpy scipy matplotlib pandas scikit-learn 安装好后，使用命令启动编辑器，启动成功后将会自动打开浏览器。1$ jupyter notebook 在jupyter notebook使用matplotlib，需在网页编辑器执行下面命令。1%matplotlib inline 参考资料Scipy getting startedScipy Lecture NotesAnacondaInstalling JupyterIndalling MatplotlibPandasInstalling scikit-learn","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://garfieldwiki.com/categories/Machine-Learning/"}],"tags":[]},{"title":"Python虚拟环境","slug":"pythonVirtualEnv","date":"2017-12-03T11:59:57.000Z","updated":"2019-03-24T02:03:36.696Z","comments":true,"path":"2017/12/03/pythonVirtualEnv/","link":"","permalink":"http://garfieldwiki.com/2017/12/03/pythonVirtualEnv/","excerpt":"目的使用virtualenv创建独立的Python开发环境。","text":"目的使用virtualenv创建独立的Python开发环境。 简介在开发Python项目的时候，如果两个项目引用了同一个包，但是版本不同，可能会导致另外的项目无法运行，为了避免包冲突问题，需要创建一个独立干净的开发环境。 安装配置这里主要介绍如何使用virtualenvwrapper。 安装virtualenv。 1$ [sudo] pip install virtualenv 安装virtualenvwrapper，这个是对virtualenv的扩展，提供了更便捷的命令。 1$ [sudo] pip install virtualenvwrapper 配置环境变量，保存以下命令至~/.bash_profile。 1source /usr/local/bin/virtualenvwrapper.sh 更新环境变量。 1$ source ~/.bash_profile 常用命令 workon：列出当前所有的环境。 mkvirtualenv myEnv：创建虚拟环境myEnv。 mkvirtualenv myEnv -p python3：指定虚拟环境的Python版本。 workon myEnv：切换当前环境到myEnv。 lsvirtualenv：列出当前所有的环境。 showvirtualenv：查看环境详细信息。 rmvirtualenv：移除环境。 deactivate：退出虚拟环境。 * 虚拟环境目录在/Users/garfield/.virtualenvs下面。 参考资料virtualenvvirtualenv Documentationvirtualenvwrappervirtualenvwrapper Documentation","categories":[{"name":"Python","slug":"Python","permalink":"http://garfieldwiki.com/categories/Python/"}],"tags":[]},{"title":"使用Ionic3进行移动开发","slug":"Ionic3","date":"2017-11-30T16:15:25.000Z","updated":"2019-03-24T02:03:36.676Z","comments":true,"path":"2017/12/01/Ionic3/","link":"","permalink":"http://garfieldwiki.com/2017/12/01/Ionic3/","excerpt":"目的Ionic3搭建Android和IOS应用，以及Ionic CLI常用命令使用。","text":"目的Ionic3搭建Android和IOS应用，以及Ionic CLI常用命令使用。 简介对比Ionic1.x，之后的版本进行了很大的改变，使用了基于Typescript开发的Angular，而且Angular内置了Sass进行样式管理，弥补了1.x版本需要自己进行样式管理的麻烦。 内容项目创建 环境配置。 1$ npm install -g ionic cordova 创建项目demo。使用参数--type=ionic1可以创建Ionic1.x项目。 12$ ionic start demo tabs# ionic start demo --type=ionic1 Ionic3提供了以下几个模板，这里选用tabs进行初始化项目。 tabs : a simple 3 tab layout sidemenu: a layout with a swipable menu on the side blank: a bare starter with a single page super: starter project with over 14 ready to use page designs tutorial: a guided starter project 本地运行，可以使用浏览器进行调试开发。 12$ cd demo$ ionic serve IOS模拟器 在Mac环境下，安装Xcode。 安装好后，执行以下命令安装命令工具。 12$ xcode-select --install$ npm install -g ios-deploy 使用Ionic CLI添加IOS环境 1$ ionic cordova platform add ios 模拟器运行APP。--livereload能够实时的同步修改到模拟器。 1$ ionic cordova emulate ios --livereload Android模拟器 在Mac环境下安装好Java JDK，配置环境变量。 下载Android Studio IDE，配置SDK和AVD。 使用Ionic CLI添加Android环境 1$ ionic cordova platform add android 模拟器运行APP。--livereload能够实时的同步修改到模拟器。 1$ ionic cordova emulate android --livereload Ionic CLI常用命令使用 ionic docs：命令行打开Ionic开发文档。 ionic info：查看环境配置信息。 ionic start：新建Ionic项目。 ionic build：构建网页资源。 ionic serve：本地运行，可以使用浏览器进行调试开发。 ionic generate：快速生成pipes, components, pages, directives, providers, and tabs组件。 ionic cordova requirements：查看环境配置需求。 ionic cordova prepare：构建网页资源。 ionic cordova compile：编译移动项目。 ionic cordova build：构建网页资源，编译移动项目。 ionic cordova emulate：运行应用模拟器。 ionic cordova platform add：添加移动开发平台。 ionic cordova plugin：插件管理。 ionic cordova run：在真机运行应用。 参考资料Installing IoniciOS Platform GuideDeploying to a Devicesdkmanager","categories":[{"name":"Mobile","slug":"Mobile","permalink":"http://garfieldwiki.com/categories/Mobile/"}],"tags":[{"name":"Hybrid App","slug":"Hybrid-App","permalink":"http://garfieldwiki.com/tags/Hybrid-App/"}]},{"title":"Angular环境配置","slug":"angular5","date":"2017-11-24T14:00:06.000Z","updated":"2019-03-24T02:03:36.681Z","comments":true,"path":"2017/11/24/angular5/","link":"","permalink":"http://garfieldwiki.com/2017/11/24/angular5/","excerpt":"目的如何配置Angular5环境，使用Angular CLI进行辅助开发。","text":"目的如何配置Angular5环境，使用Angular CLI进行辅助开发。 简介Angular后期版本使用TypeScript进行开发，不同于1.x版本。 内容 确保node 6.9.x ／ npm 3.x.x 以上版本。执行Angular CLI安装命令。 1$ npm install -g @angular/cli 创建应用。 1$ ng new my-app ng serve可以启动自带的服务器，方便在浏览器调试应用。 12$ cd my-app$ ng serve --open ng generate component component-name自动生成组件。ng generate directive|pipe|service|class|guard|interface|enum|module。 ng build构建项目，将生成的文件放置目录dist/，使用-prod构建生产线项目。 ng test使用Karma执行单元测试。 ng e2e使用Protractor执行端对端测试。 ng help查看更多帮助文档。 参考资料Angular Quick Start","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://garfieldwiki.com/categories/JavaScript/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://garfieldwiki.com/tags/Angular/"}]},{"title":"NGINX如何禁止或者限制IP访问","slug":"nginxBlockIp","date":"2017-11-09T07:59:32.000Z","updated":"2019-03-24T02:03:36.693Z","comments":true,"path":"2017/11/09/nginxBlockIp/","link":"","permalink":"http://garfieldwiki.com/2017/11/09/nginxBlockIp/","excerpt":"目的如果服务器被DDOS攻击，可以有效解决服务器压力。","text":"目的如果服务器被DDOS攻击，可以有效解决服务器压力。 内容 NGINX使用ngx_http_access_module模块进行IP访问控制。语法如下: 1234deny ipAddress;allow ipAddress;deny all;allow all; 建立黑名单。 编辑nginx.conf文件，添加内容。 1include blacklist.conf 新建文件blacklist.conf，填写拉黑的IP地址。 12345678#屏蔽单个IP的命令是deny 123.45.6.7;#封整个段即从123.0.0.1到123.255.255.254的命令deny 123.0.0.0/8;#封IP段即从123.45.0.1到123.45.255.254的命令deny 124.45.0.0/16;#封IP段即从123.45.6.1到123.45.6.254的命令是deny 123.45.6.0/24; 建立白名单，如果你希望自己的服务器仅提供给特定的IP使用。 编辑nginx.conf文件，添加内容。 1include whitelist.conf 新建文件whitelist.conf，填写可以访问的IP地址。 12allow 1.2.3.4; # 可以访问的IP，规则跟上面相同deny all; # 禁止所有人访问 特定的路径，设置特定的访问规则。 1234location /private/ &#123; allow 100.23.45.14; deny all;&#125; 如果IP被禁，服务器返回403错误，编辑nginx.conf，设置403提醒页面。 1error_page 403 /error403.html; 参考资料ngx_http_access_moduleLimiting Access to Proxied HTTP ResourcesNginx Block And Deny IP Address OR Network SubnetsBlocking/allowing IP-addresses in Nginx","categories":[{"name":"Server","slug":"Server","permalink":"http://garfieldwiki.com/categories/Server/"}],"tags":[{"name":"NGINX","slug":"NGINX","permalink":"http://garfieldwiki.com/tags/NGINX/"}]},{"title":"GoAccess可视化服务器日志","slug":"goacess","date":"2017-11-09T07:07:36.000Z","updated":"2019-03-24T02:03:36.683Z","comments":true,"path":"2017/11/09/goacess/","link":"","permalink":"http://garfieldwiki.com/2017/11/09/goacess/","excerpt":"目的可视化服务器日志的轻量级解决方案。","text":"目的可视化服务器日志的轻量级解决方案。 简介GoAccess是一款开源的实时的服务器日志分析和可视化软件，可以直接运行在终端里面，也可以在浏览器查看日志报告。 内容GoAccess支持自定义日志格式解析，默认格式支持有Apache, Nginx, Amazon S3, Elastic Load Balancing, CloudFront等。 本博文介绍在Ubuntu环境下如何查看Nginx日志。 安装 1$ sudo apt install goaccess 运行Nginx默认日志目录为/var/log/nginx，Nginx默认日志格式为COMBINED。 12345678910# 终端模式$ goaccess -f access.log --log-format=COMBINED# 浏览器静态模式$ goaccess -f access.log -o report.html --log-format=COMBINED# 浏览器实时模式$ goaccess -f access.log -o report.html --log-format=COMBINED --real-time-html# 查看多个文件$ goaccess access.log access.log.1# 查看当前文件目录的所有日志$ zcat access.log.*.gz | goaccess access.log - 日志格式COMBINED | Combined Log FormatVCOMBINED | Combined Log Format with Virtual HostCOMMON | Common Log FormatVCOMMON | Common Log Format with Virtual HostW3C | W3C Extended Log File FormatSQUID | Native Squid Log FormatCLOUDFRONT | Amazon CloudFront Web DistributionCLOUDSTORAGE | Google Cloud StorageAWSELB | Amazon Elastic Load BalancingAWSS3 | Amazon Simple Storage Service (S3) 参考资料Download GoAccessGet startedMan Page","categories":[{"name":"Server","slug":"Server","permalink":"http://garfieldwiki.com/categories/Server/"}],"tags":[{"name":"Dashboard","slug":"Dashboard","permalink":"http://garfieldwiki.com/tags/Dashboard/"}]},{"title":"Jenkins安装以及如何使用Pipeline","slug":"jenkins","date":"2017-11-01T07:21:13.000Z","updated":"2019-03-24T02:03:36.686Z","comments":true,"path":"2017/11/01/jenkins/","link":"","permalink":"http://garfieldwiki.com/2017/11/01/jenkins/","excerpt":"目的简单介绍如何部署Jenkins，讲解一下如何使用Pipeline，版本为Jenkins ver. 2.73.2。","text":"目的简单介绍如何部署Jenkins，讲解一下如何使用Pipeline，版本为Jenkins ver. 2.73.2。 简介Jenkins是进行项目持续集成(Continuous Integration)的必备利器，可以实现项目的自动化构建，测试和部署。 安装任何环境下都需要预装JDK或者JRE，安装Jenkins默认端口为8080。 Windows：Jenkins的安装在Windows非常简单，只需要下载Windows的.msi文件，按照提示安装即可。 macOS：可以直接下载安装包，或者使用Homebrew进行安装。 1234# 安装最新版本$ brew install jenkins# 安装LTS版本$ brew install jenkins-lts Debian/Ubuntu：安装LTS版本。 1234$ wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -$ deb https://pkg.jenkins.io/debian-stable binary/$ sudo apt-get update$ sudo apt-get install jenkins WAR：可以直接下载WAR包，然后放到Tomcat webapps目录下运行。或者使用Java命令，使用自带的服务器Jetty运行。 1$ java -jar jenkins.war --httpPort=8080 Docker：通过Docker容器运行。 12$ docker pull jenkins/jenkins$ docker run -d -p 49001:8080 -v $PWD/jenkins:/var/jenkins_home -t jenkins/jenkins PipelineJenkins Pipeline简单的讲就是将项目的构建，测试和部署等相关的动作进行脚本化，然后让Jenkins自动执行相关的脚本命令。这里介绍如何使用Jenkinsfile文件让Jenkins自动化执行脚本，该脚本使用的语法格式为 Pipeline Domain Specific Language (DSL) syntax。Jenkinsfile放在项目的根目录，方便项目进行版本控制和跟踪，示例代码使用Maven管理项目。12345678910111213141516171819202122232425262728293031323334353637383940414243pipeline &#123; agent any stages &#123; stage('Build') &#123; steps &#123; echo 'Building..' sh 'mvn -B -DskipTests clean package' &#125; &#125; stage('Test') &#123; steps &#123; echo 'Testing..' sh 'mvn test' &#125; post &#123; always &#123; junit 'reports/**/*.xml' &#125; success &#123; echo 'I succeeeded!' &#125; unstable &#123; echo 'I am unstable :/' &#125; failure &#123; echo 'I failed :(' mail to: 'team@example.com', subject: \"Failed Pipeline: $&#123;currentBuild.fullDisplayName&#125;\", body: \"Something is wrong with $&#123;env.BUILD_URL&#125;\" &#125; changed &#123; echo 'Things were different before...' &#125; &#125; &#125; stage('Deploy') &#123; steps &#123; echo 'Deploying....' sh 'mvn install' &#125; &#125; &#125;&#125; agent：表示Jenkins要分配执行器(executor)和工作区间(workspace)给该Pipeline。 stage：表示Pipeline所处的阶段，如构建阶段，或者测试阶段，可自定义，方便在控制台进行图形化展示。 steps：表示当前阶段需要执行的任务，告诉Jenkins需要做什么，可以执行相关的脚本命令，可自定义。 sh：执行shell脚本命令，如果是在Windows下，可以使用bat来替换。 post：发送信息提示，可以设置信息提醒。 junit：使用Junit插件输出报告到指定目录。 参考资料Jenkins DownloadJenkins Debian packagesGetting Started with the Guided TourUsing Jenkins to build a Java application with Maven","categories":[{"name":"CI","slug":"CI","permalink":"http://garfieldwiki.com/categories/CI/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://garfieldwiki.com/tags/Jenkins/"}]},{"title":"Git 常见问题","slug":"gitProblems","date":"2017-10-24T02:56:38.000Z","updated":"2019-03-24T02:03:36.683Z","comments":true,"path":"2017/10/24/gitProblems/","link":"","permalink":"http://garfieldwiki.com/2017/10/24/gitProblems/","excerpt":"目的记录一下Git使用过程中出现的问题。","text":"目的记录一下Git使用过程中出现的问题。 内容 使用git push命令的时候，一直停留在writing object: 100%。1$ git config --global sendpack.sideband false","categories":[{"name":"Git","slug":"Git","permalink":"http://garfieldwiki.com/categories/Git/"}],"tags":[]},{"title":"Kanban管理","slug":"kanban","date":"2017-10-18T07:43:30.000Z","updated":"2019-03-24T02:03:36.689Z","comments":true,"path":"2017/10/18/kanban/","link":"","permalink":"http://garfieldwiki.com/2017/10/18/kanban/","excerpt":"目的介绍如何应用Kanban进行软件开发。","text":"目的介绍如何应用Kanban进行软件开发。 简介Kanban管理起源于丰田公司，是一种优化生产的管理方式。 内容在软件开发中，Kanban管理可通过一块白板和便利贴将软件开发流程可视化，能够直观的看到整个团队目前任务的数量和状态，通过视图替代文字描述，减少开发过程中的沟通成本。 Kanban核心原则 Visualize Work Limit Work in Process Focus on Flow Continuous Improvement Visualize Work 可视化工作任务可视化工作任务，可以在白板上观察到工作的进展，便于发现问题，提高沟通和合作效率。 Limit Work in Process 限制半成品限制开发流程中积压的未完成的工作任务的数量，可以减少任务在白板中逗留的时间。同时也可以减少由于任务数量的积压，而导致的任务切换和重新进行优先级排序的额外工作量。 Focus on Flow 关注过程流限制未完成的任务的积压数量，发现开发过程中出现的问题和瓶颈，对开发过程进行优化，让开发工作更顺利的进行。 Continuous Improvement 持续提升落实Kanban管理，让持续提升的文化奠定基础。团队可以通过跟踪过程流，软件质量，生产效率，交付时间等来评估团队的效率。根据实际项目开发的需要不断改进Kanban管理方式，进而持续提升整个团队的开发效率。 参考资料What is Kanban? | LeanKitWHAT IS A KANBAN BOARD?How the kanban methodology applies to software development","categories":[{"name":"Agile","slug":"Agile","permalink":"http://garfieldwiki.com/categories/Agile/"}],"tags":[{"name":"Kanban","slug":"Kanban","permalink":"http://garfieldwiki.com/tags/Kanban/"}]},{"title":"MySQL用户管理和权限管理","slug":"mysqlAccount","date":"2017-10-16T06:22:07.000Z","updated":"2019-03-24T02:03:36.692Z","comments":true,"path":"2017/10/16/mysqlAccount/","link":"","permalink":"http://garfieldwiki.com/2017/10/16/mysqlAccount/","excerpt":"目的使用MySQL管理不同用户，分别授予不同的权限。","text":"目的使用MySQL管理不同用户，分别授予不同的权限。 简介在系统应用中，一个数据库可能为多个应用系统提供服务，不可能给每个系统都使用root用户权限，需要给不同的系统或者用户提供不同的用户权限，同时也避免root用户被泄露的安全风险。 用户管理MySQL账户信息都保存在mysql这个database里面，账户名由用户名和主机名组成&#39;user_name&#39;@&#39;host_name&#39;。 登录MySQL数据库 123456## 登录本地数据库$ mysql --user=user_name --password db_name$ mysql -u user_name -p db_name## 登录远程数据库$ mysql --host=host_name --user=myname --password db_name$ mysql -h host_name -u myname -p db_name 创建用户 12345mysql&gt; CREATE USER 'garfield'@'localhost' IDENTIFIED BY 'password';## 登陆后需修改密码才能继续操作mysql&gt; CREATE USER 'garfield'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE;## 每隔180天需要重新修改密码mysql&gt; CREATE USER 'garfield'@'localhost' PASSWORD EXPIRE INTERVAL 180 DAY; 用户密码管理 123456789101112## 修改密码mysql&gt; ALTER USER 'garfield'@'localhost' IDENTIFIED BY 'new_password';## 登陆后需修改密码才能继续操作mysql&gt; ALTER USER 'garfield'@'localhost' PASSWORD EXPIRE;## 用户用新密码登录后需重新修改密码mysql&gt; ALTER USER 'garfield'@'localhost' IDENTIFIED BY 'new_password' PASSWORD EXPIRE;## 每隔180天需要重新修改密码mysql&gt; ALTER USER 'garfield'@'localhost' PASSWORD EXPIRE INTERVAL 180 DAY;## 取消密码过期mysql&gt; ALTER USER 'garfield'@'localhost' PASSWORD EXPIRE NEVER;## 不推荐使用该方法修改密码，推荐使用ALTERmysql&gt; SET PASSWORD FOR 'garfield'@'localhost' = 'new_password'; 删除用户 1mysql&gt; DROP USER 'garfield'@'localhost'; 锁定用户账户 12mysql&gt; ALTER USER 'garfield'@'localhost' ACCOUNT LOCK;mysql&gt; ALTER USER 'garfield'@'localhost' ACCOUNT UNLOCK; 更改账户信息 1mysql&gt; RENAME USER 'garfield'@'localhost' TO 'garfield'@'127.0.0.1'; 权限管理在授予用户权限的时候，应该遵守按需供给，根据需要赋予权限。 查看用户权限12345mysql&gt; SHOW GRANTS FOR 'garfield'@'localhost';## 查看当前用户权限mysql&gt; SHOW GRANTS;mysql&gt; SHOW GRANTS FOR CURRENT_USER;mysql&gt; SHOW GRANTS FOR CURRENT_USER(); MySQL权限有多个层面的权限控制: Object Quoting Guidelines Privileges Supported by MySQL Global Privileges Database Privileges Table Privileges Column Privileges Stored Routine Privileges Proxy User Privileges Account Names and Passwords Implicit Account Creation Other Account Characteristics MySQL and Standard SQL Versions of GRANT 本博文从数据库Database Privileges，数据表Table Privileges和数据表的列Column Privileges三个层面介绍权限管理。 Database Privileges给用户授予数据库级别的操作权限。 12mysql&gt; GRANT ALL ON mydb.* TO 'someuser'@'somehost';mysql&gt; GRANT SELECT, INSERT ON mydb.* TO 'someuser'@'somehost'; Table Privileges给用户授予数据库表级别的操作权限。 12mysql&gt; GRANT ALL ON mydb.mytbl TO 'someuser'@'somehost';mysql&gt; GRANT SELECT, INSERT ON mydb.mytbl TO 'someuser'@'somehost'; Column Privileges给用户授予数据库表的列级别的操作权限。 1mysql&gt; GRANT SELECT (col1), INSERT (col1,col2) ON mydb.mytbl TO 'someuser'@'somehost'; 撤销权限 12mysql&gt; REVOKE INSERT ON *.* FROM 'garfield'@'localhost';mysql&gt; REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ... 参考资料MySQL SecurityMySQL User Account ManagementPrivileges Provided by MySQL","categories":[{"name":"Databases","slug":"Databases","permalink":"http://garfieldwiki.com/categories/Databases/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://garfieldwiki.com/tags/MySQL/"}]},{"title":"NGINX反向代理和负载均衡","slug":"nginxLoadBalancing","date":"2017-09-27T12:53:11.000Z","updated":"2019-03-24T02:03:36.694Z","comments":true,"path":"2017/09/27/nginxLoadBalancing/","link":"","permalink":"http://garfieldwiki.com/2017/09/27/nginxLoadBalancing/","excerpt":"目的如何使用NGINX进行反向代理(Reverse Proxy)和负载均衡(Load Balancing)。","text":"目的如何使用NGINX进行反向代理(Reverse Proxy)和负载均衡(Load Balancing)。 简介NGINX提供了应用程序的横向扩展(Horizontal Scaling)的能力，使用反向代理和负载均衡来构建应用系统，能够有效的提升系统整体性能，减少响应时间和提高网站安全，同时能够避免因为某个节点宕机而影响整个系统，NGINX支持HTTP，HTTPS，TCP和UDP协议的负载均衡。 反向代理 Reverse Proxy反向代理是指代理服务器将客户端请求转发至不同的服务器，然后将服务器结果返回给客户端。比如百度等大型网站，网站入口只有www.baidu.com，但是其背后有成千上万个服务器提供请求服务。 强大的处理并发请求的能力，内存消耗低，高性能。 能够隐藏真实的服务器地址和服务器信息。 由于无法直接访问真实服务器，能够有效的转移DDOS攻击。 代理服务器只能提供有限的权限，请求必须通过代理服务器，不能直接访问真实的服务器。 可以设置代理缓存，提供静态资源缓存服务，提高网站加载速度。 反向代理将请求转发至不同的服务器，可以提高网站的负载能力。 在location里面使用proxy_pass转发请求。/some/path/page.html将会被代理至http://www.example.com/link/page.html。123location /some/path/ &#123; proxy_pass http://www.example.com/link/;&#125; 如下设置可以将路径为/garfield/的请求代理至服务器端口为8090的应用，并解决资源相对路径无法正确请求的问题。12345location /garfield/ &#123; proxy_pass http://www.garfieldwiki.com:8090/; proxy_redirect http://$host/ /garfield/; proxy_set_header Host $host;&#125; 负载均衡 Load Balancing负载均衡就是根据某种方法，将客户端请求分发至服务器池的不同服务器进行处理。 负载均衡默认方法为轮询，可以使用upstream进行服务器池配置。12345678910111213141516http &#123; upstream myapp1 &#123; server srv1.example.com; server srv2.example.com; server srv3.example.com; &#125; server &#123; listen 80; server_name example.com; location / &#123; proxy_pass http://myapp1; &#125; &#125;&#125; NGINX负载均衡有4种方式： Round-robin：按客户端请求顺序分配，默认采用该方式。可以设置权重，权重越高，被分配的请求数越多，默认权重为1。 12345upstream backend &#123; server backend1.example.com weight=3; server backend2.example.com; server backend3.example.com;&#125; least_conn：将请求优先分配至活跃连接数最少的服务器。 123456upstream backend &#123; least_conn; server backend1.example.com; server backend2.example.com;&#125; ip_hash：将请求的IP地址通过哈希定位到后端服务器，其后的访问还是在同一台服务器，这样能够保持SESSION信息一致，但是无法保证后端服务器的负载均衡，可能有些服务器接收的请求多，有些接收的请求少。 如果某个服务器需要临时移除，需要在后面加入down参数。如果直接删除该服务器地址，那么将会重新进行哈希计算，请求将重新分配至不同的服务器。 1234567upstream backend &#123; ip_hash; server backend1.example.com; server backend2.example.com; server backend3.example.com down;&#125; hash：通过客户端请求的信息进行哈希，可以是IP地址，端口号或者URL。 1234567upstream backend &#123; hash $request_uri consistent; # hash $remote_addr$remote_port consistent; server backend1.example.com; server backend2.example.com;&#125; 参考资料Understanding Nginx HTTP Proxying, Load Balancing, Buffering, and CachingNGINX LOAD BALANCING – HTTP LOAD BALANCERUsing nginx as HTTP load balancerNGINX REVERSE PROXY","categories":[{"name":"Server","slug":"Server","permalink":"http://garfieldwiki.com/categories/Server/"}],"tags":[{"name":"NGINX","slug":"NGINX","permalink":"http://garfieldwiki.com/tags/NGINX/"}]},{"title":"OpenCV macOS 环境配置","slug":"opencv","date":"2017-09-13T12:26:57.000Z","updated":"2019-03-24T02:03:36.694Z","comments":true,"path":"2017/09/13/opencv/","link":"","permalink":"http://garfieldwiki.com/2017/09/13/opencv/","excerpt":"目的如何在macOS环境下进行OpenCV的配置，使用Python进行计算机视觉(Computer Vision)开发。","text":"目的如何在macOS环境下进行OpenCV的配置，使用Python进行计算机视觉(Computer Vision)开发。 简介OpenCV是开源的计算机视觉类库，支持C，C++，Java，Python编程语言，可以进行跨平台开发，该类库集成了图像和视频的输入输出，图像处理，物体识别，机器学习和深度神经网络等实用工具类。 内容本博文基于Python3.6和OpenCV3进行讲解，当前系统版本为macOS 10.12+，在macOS系统上面安装OpenCV是一件非常操蛋的事情。 安装Xcode，如果是第一次安装使用，需要获得苹果开发者授权，安装完后，执行命令，按照提示输入accept。 1$ sudo xcodebuild -license 安装苹果命令行工具，该工具包含了make，GCC，clang。该步骤是必须要执行的。 1$ sudo xcode-select --install 安装苹果系统包管理器Homebrew，类似Debian系统系列的apt-get。 1$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" macOS系统虽然自带了Python，但是为了避免与系统冲突，我们自己安装专门进行开发的Python。 1$ brew install python3 检查Python版本是否正确安装配置环境变量。 12$ which python3/usr/local/bin/python3 如果Python没有配置好环境变量，需要手动更新环境变量~/.bash_profile。 12# Python3export PATH=/usr/local/bin/python3:$PATH 更新环境变量配置。 1$ source ~/.bash_profile 安装Python虚拟环境virtualenv和virtualenvwrapper。 1$ pip install virtualenv virtualenvwrapper 如果出现OSError: [Errno 1] Operation not permitted by six，可使用下面命令行解决问题。 1$ sudo pip install virtualenvwrapper --ignore-installed six 配置环境变量~/.bash_profile。 12# Virtualenv/VirtualenvWrappersource /usr/local/bin/virtualenvwrapper.sh 更新环境变量。 1$ source ~/.bash_profile 创建Python3虚拟环境，使用mkvirtualenv。使用该命令创建名为cv的虚拟环境，该环境独立于系统其他环境，有自己独立的包目录，避免包冲突。 1$ mkvirtualenv cv -p python3 进入创建好的cv环境。 1$ workon cv 安装Numpy。 1$ pip install numpy 正式编译之前，需要安装编译，图像I/O和优化相关的工具包的。 123$ brew install cmake pkg-config$ brew install jpeg libpng libtiff openexr$ brew install eigen tbb 从Gitub下载OpenCV源代码。 123$ cd ~$ git clone https://github.com/opencv/opencv$ git clone https://github.com/opencv/opencv_contrib 接下来正式开始编译配置，首先创建并进入编译目录。 123$ cd ~/opencv$ mkdir build$ cd build 构建自己环境的CMake命令，这里给出的是该命令的模版。 1234567891011$ cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib/modules \\ -D PYTHON3_LIBRARY=YYY \\ -D PYTHON3_INCLUDE_DIR=ZZZ \\ -D PYTHON3_EXECUTABLE=$VIRTUAL_ENV/bin/python \\ -D BUILD_opencv_python2=OFF \\ -D BUILD_opencv_python3=ON \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D INSTALL_C_EXAMPLES=OFF \\ -D BUILD_EXAMPLES=ON .. 替换上面命令的YYY和ZZZ，可参考我本地的配置，不要复制粘贴，每个人的机器配置会有不同。PYTHON3_LIBRARY=YYY：libpython3.6.dylib的路径。PYTHON3_INCLUDE_DIR=ZZZ：python3.6m的路径。 1234567891011$ cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib/modules \\ -D PYTHON3_LIBRARY=/usr/local/Cellar/python3/3.6.2/Frameworks/Python.framework/Versions/3.6/lib/python3.6/config-3.6m-darwin/libpython3.6.dylib \\ -D PYTHON3_INCLUDE_DIR=/usr/local/Cellar/python3/3.6.2/Frameworks/Python.framework/Versions/3.6/include/python3.6m \\ -D PYTHON3_EXECUTABLE=$VIRTUAL_ENV/bin/python \\ -D BUILD_opencv_python2=OFF \\ -D BUILD_opencv_python3=ON \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D INSTALL_C_EXAMPLES=OFF \\ -D BUILD_EXAMPLES=ON .. 配置好后，执行该命令。 开始编译，编译时间在30-90分钟左右，取决于你的机器配置。 1$ make -j4 编译完后，如果没有出现错误，执行安装命令。 1$ sudo make install 安装成功后，检查python包安装目录是否有类似cv2.cpython-35m-darwin.so的文件。 123$ cd /usr/local/lib/python3.6/site-packages/$ ls -l *.so-rwxr-xr-x 1 root admin 3694564 Nov 15 11:28 cv2.cpython-35m-darwin.so 将cv2.cpython-35m-darwin.so重新命名为cv2.so。 1234567$ cd /usr/local/lib/python3.6/site-packages/$ mv cv2.cpython-35m-darwin.so cv2.so$ cd ~$ cd ~/.virtualenvs/cv/lib/python3.6/site-packages/$ ln -s /usr/local/lib/python3.6/site-packages/cv2.so cv2.so$ cd ~ 校验OpenCV是否已经正确安装并引入。 123456789$ workon cv$ pythonPython 3.6.2 (default, Jul 17 2017, 16:44:45)[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import cv2&gt;&gt;&gt; cv2.__version__'3.3.0-dev'&gt;&gt;&gt; 参考资料OpenCV DocumentationOpenCV TutorialsHomebrew","categories":[{"name":"Computer Vision","slug":"Computer-Vision","permalink":"http://garfieldwiki.com/categories/Computer-Vision/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://garfieldwiki.com/tags/OpenCV/"}]},{"title":"HTTP Message","slug":"httpMessage","date":"2017-09-12T01:53:24.000Z","updated":"2019-03-24T02:03:36.686Z","comments":true,"path":"2017/09/12/httpMessage/","link":"","permalink":"http://garfieldwiki.com/2017/09/12/httpMessage/","excerpt":"目的讲解HTTP/1.1报文格式，简单介绍HTTP协议版本的演变。","text":"目的讲解HTTP/1.1报文格式，简单介绍HTTP协议版本的演变。 简介HTTP(HyperText Transfer Protocol)：超文本传输协议，该协议定义了浏览器怎么向服务器请求文档，以及服务器怎么把文档传送给客户端，该协议由Tim Berners-Lee在1989-1991年制定，使用TCP协议进行数据传输。 HTTP请求过程浏览器是怎么向服务器请求资源？ 浏览器从URL中解析出服务器的主机名。 浏览器将服务器的主机名通过DNS域名解析，转换成服务器的IP地址。 浏览器将端口号从URL中解析出来，如果没有，就默认为80端口号。 浏览器建立一条与Web服务器的TCP的连接。 浏览器向服务器发送一条HTTP请求报文。 服务器向浏览器回送一条HTTP响应报文。 关闭连接，浏览器解析渲染文档给用户。 HTTP报文(Message)HTTP/1.1以及更久之前都使用纯文本的报文，可以直接阅读。HTTP有两种报文格式，分别是request message请求报文和response message响应报文。 两种报文结构类似，由以下组成： 起始行(Start-Line) 首部(HTTP headers) 空行(Empty-Line)：HTTP首部总是应该以一个空行CRLF结束，即使没有首部和主体也是如此。 主体(Body) HTTP Request 起始行 Start lineHTTP请求报文是从客户端发往服务器，起始行有三个字段组成，所有字段使用一个空格进行隔开： 请求方法(Method)：表示请求服务器的方式，常用的有GET和POST两种方法。如果基于RESTful的架构设计，GET用来获取资源，POST用来新建资源或更新资源，PUT用来更新资源，DELETE用来删除资源。 资源路径(Path)：通常是一个URL，可以是相对路径、绝对路径。可以在路径后面添加查询参数，一般用于表单提交或者异步请求。 HTTP版本(Version of the protocol)：显示当前使用的HTTP版本，通常是HTTP/1.1。 首部 Headers每个首部都包含一个名字，使用英文冒号:进行隔开。请求报文有三类首部： 请求首部(Request Headers)：提供有关请求的信息。 通用首部(General Headers)：既可出现在请求报文，也可出现在响应报文。可以在客户端或者服务器之间提供一些通用的功能。 实体首部(Entity Headers)：描述主体的长度和内容，或者资源自身。 主体 Body主体放置着需要发送给服务器的信息，并不是所有的请求报文都有主体，如GET、HEAD、DELETE和OPTIONS就没有。POST和PUT就有主体。主体信息在浏览器上对用户不可见，一般账户登录的信息都是放在主体里面发送，表单提交默认使用POST。 HTTP Response 起始行 Start lineHTTP响应报文是从服务器发往客户端，起始行也有三个字段组成，所有字段使用一个空格进行隔开： HTTP版本(Version of the protocol)：显示当前使用的HTTP版本，通常是HTTP/1.1。 状态码(Status Code)：表示当前请求成功或者失败。常见有200，404和302。 100~199 信息提示 200~299 成功 300~399 重定向 400~499 客户端错误 500~599 服务器错误 状态信息(Status Message)：一段简短的描述状态码意义的文本。如HTTP/1.1 404 Not Found表示找不到资源。 首部 Headers响应报文也有三类首部： 响应首部(Response Headers)：提供有关响应的信息。 通用首部(General Headers)：同上。 实体首部(Entity Headers)：同上。 主体 Body主体放着服务器返回给客户端的信息，并不是所有的响应报文都有主体，如状态码是201，204就没有。 HTTP协议版本的演变HTTP到目前为止经历了四次版本演变。 HTTP/0.9该版本非常简单，request只有一行，只有GET请求，后面跟着资源路径，只能传输HTML文件。1GET /mypage.html response也非常简单，只有HTML内容本身。123&lt;HTML&gt;A very simple HTML page&lt;/HTML&gt; HTTP/1.0增加了协议版本号(Version of the Protocol)，状态码(Status Code)，状态信息(Status Message)，HTTP头部(header)和内容类型(Content-Type)，可以传输其他类型的文件。1234567891011GET /mypage.html HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:31 GMTServer: CERN/3.0 libwww/2.17Content-Type: text/html&lt;HTML&gt;A page with an image &lt;IMG SRC=&quot;/myimage.gif&quot;&gt;&lt;/HTML&gt; 请求gif格式的图片12345678GET /myimage.gif HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:32 GMTServer: CERN/3.0 libwww/2.17Content-Type: text/gif(image content) HTTP/1.1初次标准化的HTTP协议，发布于1997年1月，仅仅在HTTP/1.0发布后几个月。对比之前的版本，该版本有了很多新的特性。该协议经过两个修订，一直沿用到至今20年(本博文写于2017年)。123456789101112131415161718192021222324252627282930313233343536373839404142GET /en-US/docs/Glossary/Simple_header HTTP/1.1Host: developer.mozilla.orgUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brReferer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header200 OKConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Wed, 20 Jul 2016 10:55:30 GMTEtag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;Keep-Alive: timeout=5, max=1000Last-Modified: Tue, 19 Jul 2016 00:59:33 GMTServer: ApacheTransfer-Encoding: chunkedVary: Cookie, Accept-Encoding(content)GET /static/img/header-background.png HTTP/1.1Host: developer.cdn.mozilla.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brReferer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header200 OKAge: 9578461Cache-Control: public, max-age=315360000Connection: keep-aliveContent-Length: 3077Content-Type: image/pngDate: Thu, 31 Mar 2016 13:34:46 GMTLast-Modified: Wed, 21 Oct 2015 18:27:50 GMTServer: Apache(image content of 3077 bytes) HTTP/2.0经过了这么多年的发展，网页已经变得非常复杂，大量的多媒体应用，脚本交互和数据传输，这种富客户端的状况有增无减，使得应用性能瓶颈日益明显。为了应对这种状况，HTTP/2.0协议于2015年5月正式发布，截止2017年5月，13.7%的前1000万名的网站支持HTTP/2.0。比起HTTP/1.1版本使用纯文本数据传输，2.0版本使用二进制格式进行数据传输。 参考资料An overview of HTTPHTTP MessagesEvolution of HTTPWikipedia HTTP/2","categories":[{"name":"Network","slug":"Network","permalink":"http://garfieldwiki.com/categories/Network/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://garfieldwiki.com/tags/Http/"}]},{"title":"计算机网络体系结构","slug":"tcpIpProtocal","date":"2017-09-10T12:22:59.000Z","updated":"2019-03-24T02:03:36.698Z","comments":true,"path":"2017/09/10/tcpIpProtocal/","link":"","permalink":"http://garfieldwiki.com/2017/09/10/tcpIpProtocal/","excerpt":"目的主要介绍 TCP/IP 网络体系结构。","text":"目的主要介绍 TCP/IP 网络体系结构。 简介计算机网络体系结构有两种，一种是国际标准 OSI（Open Systems Interconnection Reference Model），另一种是目前现行的事实上标准 TCP/IP 协议族（Transmission Control Protocol/Internet Protocol Suite），该协议族还有另一个名字是Internet协议族（Internet Protocol Suite）。 OSI 由于该协议复杂又不实用等原因，该协议并没有在现实中应用，协议分为七层： 应用层（Application Layer） 表示层（Presentation Layer） 会话层（Session Layer） 运输层（Transport Layer） 网络层（Network Layer） 数据链路层（Data-Link Layer） 物理层（Physical Layer） TCP/IP 协议族分为四层，本博文只关注上面三层： 应用层（Application Layer）：通过应用进程间的交互来完成特定网络应用。 运输层（Transport Layer)：为两个主机中进程之间的通信提供通用的数据传输服务。该层主要使用两种协议，传输控制协议TCP(Transmission Control Protocol)，和用户数据报协议UDP(User Datagram Protocol)。TCP和UDP是两种最为著名的运输层协议，二者都使用IP作为网络层协议。 网际层（Internet Layer）：也叫网络层或互联网层，为分组交换网上的不同主机提供通信服务，该层使用IP（网际）协议。 网络接口层（Network Interface Layer）：也叫链路层或数据链路层。 下图详细的展示了TCP/IP协议族具体内容以及和OSI对应关系。 1. 应用层1.1 HTTP协议HTTP(HyperText Transfer Protocol)：超文本传输协议，该协议定义了浏览器怎么向服务器请求文档，以及服务器怎么把文档传送给客户端。 1.2 FTP协议FTP(File Transfer Protocol)：文件传输协议，提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。 1.3 DNSDNS(Domain Name System)：域名系统，是一个分布式数据库，由它来提供IP地址和主机名之间的映射信息。 1.4 TELNET协议Telnet(Telecommunication Network Protocol)：是标准的提供远程登陆功能的应用，使用TCP协议连接，几乎每个TCP/IP的实现都提供了这个功能。它能够运行在不同操作系统的主机之间，但是该连接是明文传输口令和数据，并不安全，推荐使用SSH加密进行远程登陆主机。 1.5 SSH协议SSH(Secure Shell)：专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题，可以把所有传输的数据进行加密。 12可以使用该命令登陆远程服务器$ ssh root@127.0.0.1 1.6 SMTP协议SMTP(Simple Mail Transfer Protocol)：简单邮件传输协议，它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 2. 运输层2.1 TCP协议TCP(Transmission Control Protocol)：传输控制协议，为两台主机提供高可靠性的数据通信。虽然TCP使用不可靠的IP服务，但是它却提供一种可靠的运输层服务。 TCP提供一种面向连接的、可靠的字节流服务。 TCP为应用层提供全双工服务，数据能在两个方向上独立地进行传输。 TCP建立一个连接需要进行三次握手（three-way handshake)，这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明自己是谁。而终止一个连接需要经过四次握手。 使用TCP协议的应用层协议：FTP, TELNET, SSH, HTTP, SMTP 2.2 UDP协议UDP(User Datagram Protocol)：用户数据报协议，为应用层提供一种非常简单的服务，它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。和TCP不同，UDP是不可靠的，它不能保证数据报能安全无误地到达最终目的。 使用UDP协议的应用层协议：DNS, TFTP, DHCP * 2.3 应用编程接口使用TCP/IP协议的应用程序通常采用Socket进行网络编程，该编程接口可以使用TCP或UDP进行通信。严格的讲，Socket不是一种协议，而是一种编程方法。 3. 网络层3.1 IP协议IP是TCP/IP协议族中最为核心的协议。所有的TCP，UDP，ICMP及IGMP数据都以IP数据报格式传输。IP提供不可靠(Unreliable)、无连接(Connectionless)的数据报传送服务，任何要求的可靠性必须由上层来提供（如TCP）。 4. Wireshark可以使用Wireshark配合学习计算机网络各个层的数据包结构，它可以进行数据包抓取，是一款优秀的开源的网络嗅探和数据包分析利器。 参考资料TCP/IP Protocols GuideLinux Tutorial TCP-IPWiresharkWikipedia Internet protocol suite","categories":[{"name":"Network","slug":"Network","permalink":"http://garfieldwiki.com/categories/Network/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://garfieldwiki.com/tags/TCP/"}]},{"title":"Spring配置ActiveMQ和Tibco EMS","slug":"jmsConfig","date":"2017-09-06T03:14:00.000Z","updated":"2019-03-24T02:03:36.687Z","comments":true,"path":"2017/09/06/jmsConfig/","link":"","permalink":"http://garfieldwiki.com/2017/09/06/jmsConfig/","excerpt":"目的如何使用Spring配置ActiveMQ和Tibco EMS(TIBCO Enterprise For JMS)。","text":"目的如何使用Spring配置ActiveMQ和Tibco EMS(TIBCO Enterprise For JMS)。 Preparation Maven Spring Framework ActiveMQ or Tibco EMS ActiveMQ 添加spring-jms和ActiveMQ的依赖。 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.3.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-core&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt;&lt;/dependency&gt; applicationContext.xml配置。ActiveMQ地址: tcp://localhost:61616监听队列: garfield监听类: com.garfieldwiki.jms.QueueConsumer 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://localhost:61616\"/&gt; &lt;/bean&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"queueDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg&gt; &lt;value&gt;garfield&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"queueConsumer\" class=\"com.garfieldwiki.jms.QueueConsumer\"/&gt; &lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"queueDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"queueConsumer\" /&gt; &lt;/bean&gt;&lt;/beans&gt; com.garfieldwiki.jms.QueueConsumer，该类继承了MessageListener，监听队列的消息。 1234567891011121314151617181920212223package com.garfieldwiki.jms;import java.util.logging.Logger;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class QueueConsumer implements MessageListener &#123; private static final Logger LOGGER = Logger.getLogger(QueueConsumer.class.getName()); public void onMessage(Message message) &#123; try &#123; TextMessage textMsg = (TextMessage) message; LOGGER.info(\"Receive a message from garfield queue: \" + textMsg.getText()); &#125; catch (JMSException e) &#123; LOGGER.warning(e.getMessage()); &#125; &#125;&#125; com.garfieldwiki.jms.QueueProducer，该类可以发送消息到队列，使用JmsTemplate进行消息发送。 1234567891011121314151617181920212223242526272829303132333435363738package com.garfieldwiki.jms;import java.util.logging.Logger;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Queue;import javax.jms.Session;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import org.springframework.stereotype.Component;@Componentpublic class QueueProducer &#123; private static final Logger LOGGER = Logger.getLogger(QueueProducer.class.getName()); @Autowired private JmsTemplate jmsTemplate; @Autowired @Qualifier(\"queueDestination\") private Queue queue; public void sendMessage() &#123; this.jmsTemplate.send(this.queue, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; String msg = \"Hello, I am Garfield.\"; LOGGER.info(\"Send message to garfield queue: \" + msg); return session.createTextMessage(msg); &#125; &#125;); &#125;&#125; Tibco EMS 引入必要的jar包jms-2.0.jar和tibjms.jar，可在Tibco的安装目录寻找C:\\tibco\\ems\\8.3\\lib。 项目只需要引入spring-jms即可。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.3.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; applicationContext.xml配置跟ActiveMQ有不同，主要是相关实现类的命名方式不一样。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"targetConnectionFactory\" class=\"com.tibco.tibjms.TibjmsConnectionFactory\"&gt; &lt;property name=\"serverUrl\" value=\"tcp://localhost:7222\"/&gt; &lt;property name=\"userName\" value=\"\"/&gt; &lt;property name=\"userPassword\" value=\"\"/&gt; &lt;/bean&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"queueDestination\" class=\"com.tibco.tibjms.TibjmsQueue\"&gt; &lt;constructor-arg&gt; &lt;value&gt;garfield&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"queueConsumer\" class=\"com.garfieldwiki.jms.QueueConsumer\"/&gt; &lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"queueDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"queueConsumer\" /&gt; &lt;/bean&gt;&lt;/beans&gt; Tibco EMS消息的生产和消费跟ActiveMQ一样。 参考资料Spring JMSActiveMQ Spring SupportTibco EMS DocumentMaven ActiveMQ","categories":[{"name":"Spring","slug":"Spring","permalink":"http://garfieldwiki.com/categories/Spring/"}],"tags":[{"name":"JMS","slug":"JMS","permalink":"http://garfieldwiki.com/tags/JMS/"}]},{"title":"Spring Framework 概述","slug":"Spring","date":"2017-08-30T02:06:37.000Z","updated":"2019-03-24T02:03:36.679Z","comments":true,"path":"2017/08/30/Spring/","link":"","permalink":"http://garfieldwiki.com/2017/08/30/Spring/","excerpt":"目的介绍什么是Spring Framework，基于Spring Framework 4.3.10 Release进行讲解。","text":"目的介绍什么是Spring Framework，基于Spring Framework 4.3.10 Release进行讲解。 简介Spring Framework是一个实现了依赖注入的控制反转容器。该框架提供了一个轻量级的，非侵入式的，一站式的企业级应用解决方案。该方案提供了诸多的模块可供使用，该框架有以下的特征： 依赖注入 Dependency Injection 面向切面编程 Aspect-Oriented Programming 声明式事务管理 Declarative Transaction Management SpringMVC web应用和基于RESTful的web service框架 支持JDBC，JPA，JMS的集成 Much more… 内容 Spring Framework由20个模块组成，归为以下几部分： Core Container AOP and Instrumentation Messaging Data Access/Integration Web Test Core Container这部分由spring-core,spring-beans,spring-context,spring-context-support和spring-expression(Spring Expression Language)五个模块组成。spring-core和spring-beans构成了该框架的基础，里面包括了控制反转和依赖注入。 AOP and Instrumentationspring-aop提供了面向切面编程的实现。spring-aspects该模块集成了AspectJ。Instrumentation包括了spring-instrument和spring-instrument-tomcat Messaging这部分包含模块spring-messaging，为应用程序提供消息服务。 Data Access/Integration这部分由JDBC，ORM，OXM，JMS，和Transaction组成。spring-jdbc模块提供了JDBC抽象层，免去了配置JDBC的麻烦。spring-tx模块支持声明式事务管理。spring-orm模块为对象-关系型映射(Object-relational mapping)API提供了集成层，包括JPA，JDO和Hibernate。spring-oxm模块为对象-XML型映射(Object/XML mapping)提供了抽象层，包括JAXB，Castor， XMLBeans，JiBX和XStream。spring-jms模块为Java消息服务(Java Messaging Service)提供了消息的生产和消费。从Spring Framework 4.1后，spring-jms和spring-messaging一起提供消息服务。 Web这部分包含模块spring-web，spring-webmvc，spring-websocket和spring-webmvc-portlet。构建web应用需要引入这些模块，这就是俗称的SpringMVC。 Testspring-test该模块支持使用JUnit或者TestNG进行单元测试和集成测试。 Spring Framework Artifacts以下就是Spring Framework总的20个模块： GroupId ArtifactId Description org.springframework spring-aop Proxy-based AOP support org.springframework spring-aspects AspectJ based aspects org.springframework spring-beans Beans support, including Groovy org.springframework spring-context Application context runtime, including scheduling and remoting abstractions org.springframework spring-context-support Support classes for integrating common third-party libraries into a Spring application context org.springframework spring-core Core utilities, used by many other Spring modules org.springframework spring-expression Spring Expression Language (SpEL) org.springframework spring-instrument Instrumentation agent for JVM bootstrapping org.springframework spring-instrument-tomcat Instrumentation agent for Tomcat org.springframework spring-jdbc JDBC support package, including DataSource setup and JDBC access support org.springframework spring-jms JMS support package, including helper classes to send/receive JMS messages org.springframework spring-messaging Support for messaging architectures and protocols org.springframework spring-orm Object/Relational Mapping, including JPA and Hibernate support org.springframework spring-oxm Object/XML Mapping org.springframework spring-test Support for unit testing and integration testing Spring components org.springframework spring-tx Transaction infrastructure, including DAO support and JCA integration org.springframework spring-web Foundational web support, including web client and web-based remoting org.springframework spring-webmvc HTTP-based Model-View-Controller and REST endpoints for Servlet stacks org.springframework spring-webmvc-portlet MVC implementation to be used in a Portlet environment org.springframework spring-websocket WebSocket and SockJS infrastructure, including STOMP messaging support Quick Start示例代码使用Spring Framework 4.3.10，需要Java 6以上环境，这个例子简单的演示了如何使用Spring进行依赖注入，MessagePrinter与MessageService如何通过接口实现解耦。 创建Maven项目，添加spring-context依赖。 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; hello/MessageService.java类。 12345package hello;public interface MessageService &#123; String getMessage();&#125; hello/MessagePrinter.java类。 12345678910111213141516171819package hello;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class MessagePrinter &#123; final private MessageService service; @Autowired public MessagePrinter(MessageService service) &#123; this.service = service; &#125; public void printMessage() &#123; System.out.println(this.service.getMessage()); &#125;&#125; hello/Application.java类。 12345678910111213141516171819202122232425package hello;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.*;@Configuration@ComponentScanpublic class Application &#123; @Bean MessageService mockMessageService() &#123; return new MessageService() &#123; public String getMessage() &#123; return \"Hello World!\"; &#125; &#125;; &#125; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(Application.class); MessagePrinter printer = context.getBean(MessagePrinter.class); printer.printMessage(); &#125;&#125; 最后程序输出Hello World!。 参考资料Spring FrameworkSpring Framework Reference Document","categories":[{"name":"Spring","slug":"Spring","permalink":"http://garfieldwiki.com/categories/Spring/"}],"tags":[{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://garfieldwiki.com/tags/Spring-Framework/"}]},{"title":"Hibernate Validator进行数据校验","slug":"hibernateValidator","date":"2017-08-26T08:24:52.000Z","updated":"2019-03-24T02:03:36.685Z","comments":true,"path":"2017/08/26/hibernateValidator/","link":"","permalink":"http://garfieldwiki.com/2017/08/26/hibernateValidator/","excerpt":"目的使用 Hibernate Validator 进行数据校验。","text":"目的使用 Hibernate Validator 进行数据校验。 简介在应用程序的所有分层中，从表现层（Presentation Layer）到持久层（Persistent Layer）进行数据的校验都是一个非常必要的工作。如果每层都进行相同代码的数据校验，不仅费时而且也不能保证校验过程不会出错。为了避免这些重复校验的工作，开发者通常将所有的校验逻辑直接绑定在领域模型（Domain Model）里面。JSR 380 - Bean Validation 2.0里面定义了实体类（Entity）和方法的校验接口。Hibernate Validator进行了 JSR 380 接口的实现，Hibernate Validator 6 和 Bean Validation 2.0 需要 Java 8 以上。 内容接下来会介绍怎么在你的应用程序里面进行 Hibernate Validator 6 的应用。 需要 Java 8 及以上的环境。 项目使用 Apache Maven 进行依赖管理。 首先需要创建 Maven 项目，加入相关的依赖。 12345678910&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.2.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;3.0.1-b08&lt;/version&gt;&lt;/dependency&gt; 创建实体类，使用注解进行校验。 @NotNull：表示该字段不能为空。 @Size(min = 2, max = 14)：表示该字段长度在2到14之间。 @Min(2)：表示该字段的值必须大于或等于2 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.garfieldwiki.hibernate;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;public class Car &#123; @NotNull private String manufacturer; @NotNull @Size(min = 2, max = 14) private String licensePlate; @Min(2) private int seatCount; public Car(String manufacturer, String licensePlate, int seatCount) &#123; super(); this.manufacturer = manufacturer; this.licensePlate = licensePlate; this.seatCount = seatCount; &#125; public String getManufacturer() &#123; return manufacturer; &#125; public void setManufacturer(String manufacturer) &#123; this.manufacturer = manufacturer; &#125; public String getLicensePlate() &#123; return licensePlate; &#125; public void setLicensePlate(String licensePlate) &#123; this.licensePlate = licensePlate; &#125; public int getSeatCount() &#123; return seatCount; &#125; public void setSeatCount(int seatCount) &#123; this.seatCount = seatCount; &#125;&#125; 使用单元测试进行数据校验测试。这里使用Validator这个对象，该对象从ValidatorFactory这个工厂类获得，Validator是线程安全的，可以在多线程的环境下使用。validate()这个方法返回一个ConstraintViolation的Set对象，该对象存储的是所有校验后的结果，如果校验结果都通过，那么该集合的长度为0，表示成功通过校验。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.garfieldwiki.hibernate;import java.util.Set;import javax.validation.ConstraintViolation;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.ValidatorFactory;import org.junit.Assert;import org.junit.BeforeClass;import org.junit.Test;public class TestCar &#123; private static Validator validator; @BeforeClass public static void setUp() &#123; ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); validator = factory.getValidator(); &#125; @Test public void manufacturerIsNull() &#123; Car car = new Car(null, \"DD-AB-123\", 4); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car); Assert.assertEquals(1, constraintViolations.size()); Assert.assertEquals(\"must not be null\", constraintViolations.iterator().next().getMessage()); &#125; @Test public void licensePlateTooShort() &#123; Car car = new Car(\"Mirrors\", \"D\", 4); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car); Assert.assertEquals(1, constraintViolations.size()); Assert.assertEquals(\"size must be between 2 and 14\", constraintViolations.iterator().next().getMessage()); &#125; public void seatCountTooLow() &#123; Car car = new Car(\"Mirrors\", \"DD-AB-123\", 1); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car); Assert.assertEquals(1, constraintViolations.size()); Assert.assertEquals(\"must be greater than or equal to 2\", constraintViolations.iterator().next().getMessage()); &#125; @Test public void carIsValid() &#123; Car car = new Car(\"Morris\", \"DD-AB-123\", 2); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car); Assert.assertEquals(0, constraintViolations.size()); &#125;&#125; 参考资料Hibernate Validation Reference Guide","categories":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://garfieldwiki.com/categories/Hibernate/"}],"tags":[]},{"title":"Spring Boot快速构建项目","slug":"springboot","date":"2017-08-25T13:56:45.000Z","updated":"2019-03-24T02:03:36.697Z","comments":true,"path":"2017/08/25/springboot/","link":"","permalink":"http://garfieldwiki.com/2017/08/25/springboot/","excerpt":"目的如何使用Sprint Boot快速构建项目。","text":"目的如何使用Sprint Boot快速构建项目。 简介Spring Boot可以简单快速的构建基于Spring的应用系统。 构建独立运行的应用系统，不用额外配置应用服务器，开箱即用。 内置Tomcat，Jetty和Undertow应用服务器，并且不需要部署war文件，默认使用服务器Tomcat。 Spring自动化配置，提供一站式服务，彻底摆脱XML配置。 项目将会被打包为jar文件，使用java -jar即可运行。 搭建项目 使用Maven进行项目管理，创建普通Java应用项目，不是Java web项目。本教程基于Spring Boot 1.5.6 Release开发。Spring Boot依赖groupId为org.springframework.boot相关的项目，项目默认都会依赖spring-boot-starter-parent这个项目，该项目提供了构建Spring应用的基本配置和包引用。 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt;&lt;/project&gt; Spring Boot提供了一站式的配置Starter,Starters里面引用了构建项目必要的依赖和配置，示例代码使用SpringMVC搭建web应用，只需要在pom.xml里面加入spring-boot-starter-web的这个Starter依赖即可。 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在Maven项目创建目录src/main/java,在该目录下创建Java类Example.java。 12345678910111213141516171819import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 可以在IDE里面运行Main.java,然后在浏览器访问http://localhost:8080，你就会看到应用程序返回Hello World!。 创建可执行jar文件，Spring Boot提供了spring-boot-maven-plugin该插件。 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 保存pom.xml文件，执行命令mvn package进行项目打包，你可以在targe目录下找到myproject-0.0.1-SNAPSHOT.jar文件，以下是完整的pom.xml配置。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 使用命令即可运行打包好的项目java -jar target/myproject-0.0.1-SNAPSHOT.jar，无需繁琐的XML配置即可构建基于SpringMVC的Web应用程序。 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.6.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 参考资料Spring Boot DemoSpring Boot Reference GuideSpring Starter","categories":[{"name":"Spring","slug":"Spring","permalink":"http://garfieldwiki.com/categories/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://garfieldwiki.com/tags/Spring-Boot/"}]},{"title":"浏览器内核以及工作原理简述","slug":"webBrowserEngine","date":"2017-08-23T06:03:05.000Z","updated":"2019-03-24T02:03:36.701Z","comments":true,"path":"2017/08/23/webBrowserEngine/","link":"","permalink":"http://garfieldwiki.com/2017/08/23/webBrowserEngine/","excerpt":"目的介绍目前流行的浏览器内核，以及浏览器是怎么解析网页资源。","text":"目的介绍目前流行的浏览器内核，以及浏览器是怎么解析网页资源。 简介浏览器内核（Web Browser Engine, Web Layout Engine Or Web Rendering Engine）目的是进行网页资源的解析和渲染。 目前主流浏览器使用的内核： Google Chrome：基于Webkit开发的Blink IE：Trident Mozilla Firefox：Gecko Opera：Blink Safari：Webkit Microsoft Edge：EdgeHTML 内容浏览器架构 The user interface：浏览器用户界面。 The browser engine：浏览器引擎，用来查询和操作渲染引擎。 The rendering engine：渲染引擎，解析网页资源如HTML和CSS，并将解析后的结果进行渲染，显示给用户看。 Networking：网络操作，用来进行网络请求处理。 UI backend：用来绘制类似组合选择框及对话框等基本组件。 JavaScript interpreter：JS解析器，用来解析执行JS代码，如Nodejs使用的Chrome V8引擎就是JS解析器。 Data storage：浏览器端的数据存储如Cookie。 浏览器内核浏览器内核也叫渲染引擎，主要作用是进行网页资源的渲染，如将HTML和CSS解析并呈现给用户。 渲染引擎基本工作方式：解析HTML，构建DOM树-&gt;构建Render树-&gt;布局Render树-&gt;绘制Render树 渲染引擎首先进行HTML文档解析，并将HTML标签转换为DOM节点来构建Content树。 接下来进行CSS样式解析来构建Render树。Render树由一些包含有颜色和大小等属性的矩形组成，并按照一定的顺序显示到屏幕上。 构建好Render树后，进行布局管理，确定每个节点在屏幕上的确切坐标。 再下一步就是绘制，即遍历Render树，并使用UI后端层绘制每个节点。 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，一边解析一边显示，并不会等到所有的HTML都解析完成之后再去构建和布局render树。期间还可通过网络下载其余内容。 以下是具体内核的工作方式： 参考资料How Browsers Work: Behind the scenes of modern web browsersQuantum CSSBlinkGeckoWebkit","categories":[{"name":"Front End","slug":"Front-End","permalink":"http://garfieldwiki.com/categories/Front-End/"}],"tags":[{"name":"Browser","slug":"Browser","permalink":"http://garfieldwiki.com/tags/Browser/"}]},{"title":"如何使用Google搜索引擎","slug":"googleSearch","date":"2017-08-15T14:12:47.000Z","updated":"2019-03-24T02:03:36.684Z","comments":true,"path":"2017/08/15/googleSearch/","link":"","permalink":"http://garfieldwiki.com/2017/08/15/googleSearch/","excerpt":"目的善用Google引擎，优化搜索结果，提高工作效率。","text":"目的善用Google引擎，优化搜索结果，提高工作效率。 入门 查询天气weather zhuhai。 查询英文单词解释define love。 数学运算1+1。 初级 使用-排除某个关键词，比如搜索豪车除了宝马豪车 -宝马。 使用双引号进行完全匹配搜索&quot;Garfield Dai&quot;。 使用*进行模糊搜索G* Dai。 使用OR搜索，搜索宝马或者奔驰宝马OR奔驰。 使用+组合关键字。 进阶 inurl：搜索关键词出现在url。inurl:搜索引擎优化。allinurl:SEO 搜索引擎优化等同于inurl:SEO inurl:搜索引擎优化。 intitle：搜索关键词出现在title。intitle:搜索引擎优化。allintitle:SEO 搜索引擎优化等同于intitle:SEO intitle:搜索引擎优化。 intext：搜索关键词出现在正文。intext:搜索引擎优化。allintext:SEO 搜索引擎优化等同于intext:SEO intext:搜索引擎优化。 filetype：搜索特定的文档格式。filetype:pdf SEO。 site：搜索某个网站里面的信息site:www.garfieldwiki.com。 以上所有的命令支持组合使用。 参考资料知乎How to search on GoogleGoogle Hacking","categories":[{"name":"Google","slug":"Google","permalink":"http://garfieldwiki.com/categories/Google/"}],"tags":[{"name":"Search","slug":"Search","permalink":"http://garfieldwiki.com/tags/Search/"}]},{"title":"Scrum敏捷开发","slug":"scrum","date":"2017-08-07T14:20:53.000Z","updated":"2019-03-24T02:03:36.697Z","comments":true,"path":"2017/08/07/scrum/","link":"","permalink":"http://garfieldwiki.com/2017/08/07/scrum/","excerpt":"目的讲解什么是Scrum敏捷开发。","text":"目的讲解什么是Scrum敏捷开发。 简介Scrum是一个过程框架，被用来管理产品的开发和维护，它是基于经验的一套流程控制理论，采用一种迭代、增量式的方法来进行项目管理。 内容 Scrum Team（Scrum团队） Product Owner (产品负责人) Development Team（开发团队） Scrum Master（Scrum主管） Scrum Events（Scrum事件） The Sprint Sprint Planning（Sprint计划会议） Daily Scrum（每日Scrum站会） Sprint Review（Sprint评审会议） Sprint Retrospective（Sprint回顾会议） Scrum Artifacts（Scrum工件） Product Backlog（产品待办列表） Sprint Backlog（Sprint待办列表） Increment（产品增量） Scrum团队Scrum团队是跨职能的自组织团队。 跨职能：拥有完成工作所需的全部技能,不需要依赖团队之外的人。 自组织：自己选择如何以最好的方式来完成工作,而不是由团队之外的人来指导。 Scrum团队有三种角色： Product Owner (一名产品负责人) Development Team（开发团队） Scrum Master（一名Scrum主管） 产品负责人产品负责人负责如何让产品和开发团队工作的价值最大化。产品负责人是唯一一个负责管理产品待办列表的人。职责范围包括： 清晰的表达产品待办列表的每个列表项。 对产品待办列表项进行排序,使其最好地实现目标和使命。 优化开发团队的工作价值。 确保产品待办列表对所有人都是是可见的、透明的和清晰的，并且能够让Scrum团队知道下一步工作是什么。 确保开发团队对产品待办列表项有足够深的了解。 产品负责人可以亲自完成上述工作,或者也可以让开发团队来完成。然而无论何者，产品负责人是负最终责任的人。 产品负责人是一个人，想要改变产品待办列表项的优先级必须经过产品负责人。开发团队的工作范围只能限定在产品待办列表项。 开发团队开发团队包含了各种专业人员，只有他们才能在每个Sprint中提交可交付的产品增量。开发团队具有下列特点： 自我组织和领导，开发团队自己决定选择产品待办列表项的数量，不受开发团队外的人员干预（Scrum主管也不行）。 开发团队拥有开发产品的所有技能，不依靠外部人员参与。 开发团队里面没有上下层关系，所有人都拥有一样的头衔，都叫做开发人员。 开发团队里面没有子团队，没有分测试人员或者业务人员等等。 所有的责任都由整个开发团队承担。 开发团队的规模一般是3~9个人，不包括产品负责人和Scrum主管（除非他们也参与和执行Sprint待办列表中的开发工作）。人员过少会导致缺少互动和技能不够，过多会增加沟通成本和管理成本。 Scrum主管Scrum主管要确保Scrum团队遵循Scrum的理论、实践和规则。Scrum主管是一个服务型领导。 Scrum主管服务于产品负责人： 找到有效管理产品待办列表的技巧。 帮助Scrum团队理解为何需要清晰且简明的产品待办列表项。 确保产品负责人懂得如何来安排产品待办列表使其达到最大化价值。 按要求或需要引导Scrum事件。 Scrum主管服务与开发团队： 在自组织和跨职能方面给予开发团队指导。 帮助开发团队创造高价值的产品。 移除开发团队工作进展中的障碍。 按要求或需要引导Scrum事件。 在Scrum还未完全采纳和理解的组织环境中指导开发团队。 Scrum主管服务于组织： 带领并指导组织采纳Scrum。 在组织范围内规划Scrum的实施。 帮助员工和利益攸关者理解并实施Scrum和经验产品开发。 引发能够提升Scrum团队生产效率的改变。 与其他Scrum主管一起工作,增加组织中Scrum应用的有效性。 The SprintSprint是Scrum的核心，该事件持续时间为一个月以内，每个Sprint都可以被视为一个项目，在这段时间内，构建一个可发布的产品增量。在整个开发过程中，Sprint的时间长度通常保持一致，一个Sprint的结束，新的Sprint立即开始。只有产品负责人才有取消 Sprint的权力。 Sprint由Sprint计划会议、每日Scrum站会、开发工作、 Sprint评审会议和Sprint回顾会议构成。 Sprint计划会议Sprint中要做的工作在Sprint计划会议中来做计划。这份工作计划是由整个Scrum团队共同协作完成的。Sprint计划会议是限时的,以一个月的Sprint来说最多8小时为上限。 Scrum主管确保会议顺利举行以及控制会议的时间进展。 产品负责人讲解此次Sprint的目标以及所需要完成的产品待办列表项。 开发团队自己决定选择产品待办列表项的数量，只有开发团队可以评估接下来的Sprint可以完成什么工作。 开发团队需要为选择完的产品待办列表制定目标和计划。 选出的产品列表项以及对产品列表项的目标和计划构成了此次的Sprint待办列表。 会议最后，需要规划Sprint最初几天需要做的工作，通常以一天或更少为一个单位。开发团队自组织地领取Sprint待办产品列表中的工作，产品负责人能够帮助解释清楚所选定的产品待办列表项。 会议结束时，开发团队应该能够向产品负责人和Scrum主管解释他们将如何以自组织团队的形式完成Sprint目标并开发出预期的产品增量。 每日Scrum站会每次站会固定在15分钟内，让各个开发人员说明昨天工作成果，今天工作计划，以及工作中遇到的障碍。站会可以让开发人员了解当前Sprint的进度，及时发现问题，调整工作计划。Scrum主管需要控制时间在15分钟内，并且只有开发团队成员才能参加，但是会议由开发团队自己负责召开。 Sprint评审会议 Sprint评审会议是在Sprint快结束时举行。 目的是进行产品增量的演示来获取反馈，调整产品待办列表。 由Scrum团队和利益相关者协同讨论这次Sprint中所完成的工作。 对于长度为一个月的Sprint来说，评审会议的限时为4小时。 Scrum主管确保会议正常举行，并控制会议时间进度。 Sprint评审会议内容： 产品负责人邀请Scrum团队和主要利益相关者参加会议。 产品负责人说明产品待办列表项完成进度和情况。 开发团队讨论Sprint期间哪些工作做的好，遇到什么问题以及如何解决的。 开发团队演示已完成的工作并解答关于增量的问题。 参会的所有人就下一步工作进行探讨。 Sprint回顾会议 Sprint回顾会议发生在Sprint评审会议结束之后，下个Sprint计划会议之前。 参会人员仅是Scrum团队，目的是Scrum团队进行自我总结并在下一个Sprint中改进不足。 对于长度为一个月的Sprint来说,会议的限时为3小时。 Scrum主管确保会议正常举行，并控制会议时间进度。 Sprint回顾会议内容： 讨论上一个Sprint中关于人、关系、过程和工具的情况如何。 找出值得鼓励的地方以及需要改进的方面，进而优化团队工作方式。 产品待办列表产品待办列表是一份关于产品需求的有序列表。产品负责人是唯一一个负责管理产品待办列表的人。 Sprint待办列表Sprint待办列表是一组为当前Sprint选出的产品待办列表项，同时加上交付产品增量和实现Sprint目标的计划。在Sprint期间，只有开发团队可以改变Sprint待办列表。 产品增量增量是一个Sprint完成的所有产品待办列表项的总和,以及之前所有Sprint所产生的增量的价值总和。在Sprint的最后，新的增量必须是可用的。 参考资料ScrumGuides.org2016-Scrum-Guide-US2016-Scrum-Guide-Chinese-Simplified","categories":[{"name":"Agile","slug":"Agile","permalink":"http://garfieldwiki.com/categories/Agile/"}],"tags":[{"name":"Scrum","slug":"Scrum","permalink":"http://garfieldwiki.com/tags/Scrum/"}]},{"title":"Sass架构设计以及基于Gulp实现自动化构建","slug":"sassAndGulp","date":"2017-07-29T01:42:39.000Z","updated":"2019-03-24T02:03:36.696Z","comments":true,"path":"2017/07/29/sassAndGulp/","link":"","permalink":"http://garfieldwiki.com/2017/07/29/sassAndGulp/","excerpt":"目的如何使用Sass进行前端样式架构设计，并且使用Gulp进行自动化构建项目。","text":"目的如何使用Sass进行前端样式架构设计，并且使用Gulp进行自动化构建项目。 简介 在阅读Bootstrap的基于Sass的源代码后，吸收了Bootstrap架构设计的经验，来谈谈如何在实际的项目开发中搭建Sass架构。 在进行前端开发过程中，虽然可以使用Sass自带的编译命令类似sass --watch style.scss:style.css --style compact进行CSS的编译，但是自带的命令功能有限。结合Gulp的使用，可以让项目自动化构建变得更加的灵活，而并不局限于编译CSS。 内容Preparation Nodejs Sass Gulp Sass Architecture我们可以这样建立项目结构。12345678--project/ --css/ --mySass/ --_dialog.scss --_home.scss --_mixins.scss --_variables.scss --mySass.scss 在文件夹mySass里面，放置项目的Sass文件，所有的文件被引用到mySass.scss，然后使用mySass.scss进行CSS编译。 12345678/* mySass.scss *//* Core variables and mixins */@import \"mySass/variables\";@import \"mySass/mixins\";/* Module or others */@import \"mySass/home\";@import \"mySass/dialog\"; _variables.scss该文件放置项目的全局变量，_mixins.scss该文件放置项目可复用的代码块，这两个文件需要放置在最前面，因为Sass在引入文件的时候是有顺序的要求。 _dialog.scss和_home.scss这里只是样例，可以根据具体的项目进行设计，可以按照控件进行归类，也可以按照某个页面进行归类等等。 最后使用下面命令检验项目是否配置成功。 1$ sass --watch mySass.scss:mySass.min.css --style compressed GulpGulp是基于流的自动化构建工具，类似的工具有Grunt和webpack。 安装Gulp。 12$ sudo npm install --global gulp-cli$ gulp --help 初始化为node项目。 1$ npm init 将Gulp加入项目。 1$ sudo npm install --save-dev gulp 安装Sass编译插件。 1$ sudo npm install --save-dev gulp-sass 在根目录创建gulpfile.js。 当前项目结构。 1234567891011--project/ --css/ --mySass/ --_dialog.scss --_home.scss --_mixins.scss --_variables.scss --mySass.scss --node_modules/ --gulpfile.js --package.json package.json内容。 12345678910111213141516171819&#123; \"name\": \"project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"https://xxx.xxx.xxx.git\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp-sass\": \"^3.1.0\" &#125;&#125; gulpfile.js内容。 123456789101112131415161718'use strict';var gulp = require('gulp');var sass = require('gulp-sass');gulp.task('sass', function () &#123; return gulp.src('./css/mySass.scss') .pipe(sass(&#123;outputStyle: 'compressed'&#125;).on('error', sass.logError)) .pipe(gulp.dest('./css/'));&#125;);gulp.task('run', ['sass']);gulp.task('watch', function () &#123; gulp.watch('./css/**/*.scss', ['sass']);&#125;);gulp.task('default', ['run','watch']); 在根目录运行命令，gulp就会自动执行任务。 1$ gulp 至此，所有的配置完成。 参考资料BootstrapGulp DocumentGulp Sass","categories":[{"name":"CSS","slug":"CSS","permalink":"http://garfieldwiki.com/categories/CSS/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"http://garfieldwiki.com/tags/SASS/"}]},{"title":"浅谈测试驱动开发(Test-Driven Development)","slug":"tdd","date":"2017-07-25T02:11:55.000Z","updated":"2019-03-24T02:03:36.698Z","comments":true,"path":"2017/07/25/tdd/","link":"","permalink":"http://garfieldwiki.com/2017/07/25/tdd/","excerpt":"目的讲解什么是TDD。","text":"目的讲解什么是TDD。 简介简单的说，测试驱动开发就是先将需求转换为具体的测试用例再进行开发，然后将开发的程序通过测试用例去验证。 内容测试驱动开发流程 添加测试用例 运行所有测试用例，查看新增测试用例是否失败 编写代码 运行测试用例 重构代码 详细内容 添加测试用例在增加新的特征(feature)之前，需要先编写测试用例。测试用例的编写要求开发者首先需要很清楚的了解当前的条件和需求，在正确理解需求的情况下，编写正常和异常的用例。保持测试用例的小粒度可以减少debugging的工作量，可以更好的定位错误，并且能够让开发者更好的阅读和维护。 运行所有测试用例，查看新增测试用例是否失败因为没有具体的实现，所以是为了检查新增的测试用例是失败的，并且其他测试用例都是正常的。 编写代码用最简单粗暴的方式编写代码，只需要让测试用例通过即可。此阶段并不要求编写的代码足够好。 运行测试用例如果所有的测试用例通过，可说明当前的代码能够满足当前的需求，可以让开发者自信的进行下一步开发。 重构代码当前阶段需要对代码进行封装和规范命名，特别是去除重复的代码，提高代码的可读性和可维护性。边重构边跑测试用例，保证代码每次重构都可以通过测试。 参考资料Test-Driven Development","categories":[{"name":"Agile","slug":"Agile","permalink":"http://garfieldwiki.com/categories/Agile/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://garfieldwiki.com/tags/TDD/"}]},{"title":"LaTex","slug":"latex","date":"2017-07-21T01:46:56.000Z","updated":"2019-03-24T02:03:36.690Z","comments":true,"path":"2017/07/21/latex/","link":"","permalink":"http://garfieldwiki.com/2017/07/21/latex/","excerpt":"目的如何在Unix-like系统下面安装LaTex。","text":"目的如何在Unix-like系统下面安装LaTex。 简介LaTex是一个高质量的文档排版系统(Document preparation system for high-quality typesetting)，可以处理复杂的数学公式，经常被用来发布技术文档或者科学文章。LaTex不是一个文档处理器(Word processor)，LaTex让使用者专注于文档的内容而不用关心怎么进行文档排版。 LaTex可以结合版本控制系统Git，能够实现多人同步编写文档，并且可以记录整个文档修改的历史记录，可以生成PDF格式的文档，是一种工业级别的文字排版系统，这种特性是Microsoft Word所无法比拟的。 LaTex是一门标记性语言，其他标记性语言如我们熟悉的HTML，Markdown等是同属一类。 内容Ubuntu 在Ubuntu里面只需要简单一个命令就可以完成安装。 12$ sudo apt install texlive-full$ tex --version 新建样例文本，命名为hello.tex。 123456789\\documentclass&#123;article&#125;\\usepackage&#123;ctex&#125;\\title&#123;你好，世界&#125;\\author&#123;Mac&#125;\\date&#123;2015, July 4&#125;\\begin&#123;document&#125; \\maketitle 这是我呐喊出来的第一句话。\\end&#123;document&#125; 使用XeLaTex进行文档编译。 1$ xelatex hello.tex 你可以在当前目录看到生成的PDF文档hello.pdf。 安装编辑器TexStudio 1$ sudo apt install texstudio Unix-like系统手动安装 下载软件压缩包install-tl-unx.tar.gz，解压。http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet/ 进入文件夹路径，执行命令进行安装。 1$ sudo perl install-tl 安装完后，配置环境变量/home/garfield/.bashrc，将下面代码加到最后面。 1PATH=/usr/local/texlive/2017/bin/x86_64-linux:$PATH; export PATH 更新配置信息。 1$ source /home/garfield/.bashrc 检查安装成功。 12345$ tex --version# TeX 3.14159265 (TeX Live 2017)# kpathsea version 6.2.3# Copyright 2017 D.E. Knuth.# ...... 参考资料Ubuntu LaTexFormatting informationTexStudio Support ChineseWikiBooks LaTexAn Introduction to Using TeXLaTexQuick installHelp Links","categories":[{"name":"Document","slug":"Document","permalink":"http://garfieldwiki.com/categories/Document/"}],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://garfieldwiki.com/tags/LaTex/"}]},{"title":"Laravel简单安装和配置","slug":"laravel","date":"2017-07-13T13:00:20.000Z","updated":"2019-03-24T02:03:36.690Z","comments":true,"path":"2017/07/13/laravel/","link":"","permalink":"http://garfieldwiki.com/2017/07/13/laravel/","excerpt":"目的如何在Ubuntu16.04安装和配置Laravel，PHP &gt;= 5.6.4。","text":"目的如何在Ubuntu16.04安装和配置Laravel，PHP &gt;= 5.6.4。 Composer在正式安装Laravel前，你需要安装Composer，它是管理PHP依赖关系的工具。 下载composer.phar可执行文件。 123$ php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"$ php composer-setup.php$ php -r \"unlink('composer-setup.php');\" 执行完上面的命令后，你可以在当前目录找到composer.phar文件，将该文件放置全局路径里面。 1$ mv composer.phar /usr/local/bin/composer 查看Composer信息。 1$ composer Laravel 使用Composer进行安装。 1$ composer global require \"laravel/installer\" 配置环境变量,打开文件/home/garfield/.bashrc，将~/.composer/vendor/bin路径加到 PATH。 1export PATH=/home/garfield/.config/composer/vendor/bin:$PATH 让修改后的配置文件立即生效。 1$ source /home/garfield/.bashrc 配置完毕后，查看Laravel信息。 1$ laravel -v 新建Laravel项目。 1$ laravel new projectName 如果遇到下面的php zip模块异常，执行命令安装。 123# [RuntimeException] # The Zip PHP extension is not installed. Please install it and try again.$ sudo apt install php-zip 如果遇到下面php mbstring模块异常，执行命令安装。 12# laravel/framework v5.4.28 requires ext-mbstring * -&gt; the requested PHP extension mbstring is missing from your system.$ sudo apt install php-mbstring 安装完毕后，使用PHP自带的服务器运行项目，运行后地址为http://127.0.0.1:8000/。 1$ php artisan serve 参考资料Download ComposerComposerLaravel","categories":[{"name":"PHP","slug":"PHP","permalink":"http://garfieldwiki.com/categories/PHP/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://garfieldwiki.com/tags/Laravel/"}]},{"title":"Joomla简单配置和使用","slug":"joomla","date":"2017-07-09T02:29:56.000Z","updated":"2019-03-24T02:03:36.687Z","comments":true,"path":"2017/07/09/joomla/","link":"","permalink":"http://garfieldwiki.com/2017/07/09/joomla/","excerpt":"目的如何在Ubuntu16.04安装和配置Joomla。","text":"目的如何在Ubuntu16.04安装和配置Joomla。 简介Joomla是一款强大的内容管理系统（Content Management System）。 内容本博文假设你已经安装好LAMP架构。 PHP 5.6+or7+ Mysql 5.5.3+ Apache 2.4+ Joomla 3.7.3 设置PHP.ini配置，/etc/php/7.0/apache2/php.ini。 memory_limit - 最小: 64M 推荐: 128M or better upload_max_filesize - 最小: 20M post_max_size - 最小: 20M max_execution_time: 最小 120 推荐: 300 为joomla初始化数据库。 1create database joomla; 安装php模块。 1$ sudo apt-get install php7.0-mysql php7.0-curl php7.0-json php7.0-cgi php7.0 libapache2-mod-php7.0 php7.0-mcrypt php7.0-xml php7.0-xmlrpc 到 Joomla 官网下载软件压缩包。 清空/var/www/html/文件，解压压缩包到/var/www/html/。 1rm -rf /var/www/html/* 授权给/var/www/html/，重启服务器。 123$ sudo chown -R www-data.www-data /var/www/html$ sudo chmod -R 755 /var/www/html$ sudo systemctl restart apache2.service 打开http://localhost/installation/index.php就可以启动程序安装。 完成安装后，需要移除安装文件。12cd /var/www/html/rm -rf installation/ 参考资料Installing JoomlaHow to Install Joomla on Ubuntu 16","categories":[{"name":"CMS","slug":"CMS","permalink":"http://garfieldwiki.com/categories/CMS/"}],"tags":[{"name":"Joomla","slug":"Joomla","permalink":"http://garfieldwiki.com/tags/Joomla/"}]},{"title":"LAMP(Linux+Apache+Mysql+PHP)应用架构搭建","slug":"php","date":"2017-07-08T05:11:06.000Z","updated":"2019-03-24T02:03:36.695Z","comments":true,"path":"2017/07/08/php/","link":"","permalink":"http://garfieldwiki.com/2017/07/08/php/","excerpt":"目的如何在Ubuntu16.04搭建LAMP架构。","text":"目的如何在Ubuntu16.04搭建LAMP架构。 简介PHP作为世界上最好的语言，有着其内在的理由，据统计，大约70%左右的网站都使用该门语言进行开发。PHP语言对新手入门简单，学习成本底，现成解决方案成熟，其开发成本比其他语言底，是中小型企业网站建设开发和个人博客建设的首选语言。 LAMP ApplicationUbuntu系统已经提供了简单的命令进行LAMP项目的搭建。 安装tasksel。 1$ sudo apt install tasksel 搭建LAMP架构，只需要简单一条命令即可，之后按照提示操作即可。 1$ sudo tasksel install lamp-server 在/var/www/html创建php文件phpinfo.php。 123&lt;?php phpinfo();?&gt; 浏览器打开http://localhost/phpinfo.php，你就可以看到PHP相关的配置信息。 PHP 安装如果你通过tasksel安装LAMP，下面的内容就可不用看了。以下内容假设你已经安装和配置好了Apache2 Web 服务器和Mysql数据库，可以在本网站查看相关的安装教程。 安装PHP和Apache PHP模块（module）。 1$ sudo apt install php libapache2-mod-php 安装Mysql模块。 1$ sudo apt install php-mysql 重启Mysql服务。 1$ sudo systemctl restart apache2.service 在/var/www/html创建php文件phpinfo.php。 123&lt;?php phpinfo();?&gt; 浏览器打开http://localhost/phpinfo.php，你就可以看到PHP相关的配置信息。 参考资料LAMP ApplicationPHP - Scripting Language","categories":[{"name":"PHP","slug":"PHP","permalink":"http://garfieldwiki.com/categories/PHP/"}],"tags":[{"name":"LAMP","slug":"LAMP","permalink":"http://garfieldwiki.com/tags/LAMP/"}]},{"title":"MySQL简单配置和使用","slug":"mysql","date":"2017-07-08T03:45:53.000Z","updated":"2019-03-24T02:03:36.691Z","comments":true,"path":"2017/07/08/mysql/","link":"","permalink":"http://garfieldwiki.com/2017/07/08/mysql/","excerpt":"目的如何在Ubuntu16.04配置和使用MySQL。","text":"目的如何在Ubuntu16.04配置和使用MySQL。 内容 安装。 12$ sudo apt-get update$ sudo apt-get install mysql-server 完成安装后，mysql自动启动运行，可以使用下面命令检查mysql是否运行。 12$ sudo netstat -tap | grep mysql# tcp 0 0 localhost:mysql *:* LISTEN 2556/mysqld 如果mysql服务没有正确运行，可以使用该命令重启mysql服务。 1$ sudo systemctl restart mysql.service 常用命令。 1234567891011# 帮助手册$ mysql --help# 查看数据库状态$ sudo service mysql status# 停止数据库$ sudo service mysql stop# 启动数据库$ sudo service mysql start# 卸载数据库$ sudo apt-get remove mysql-server$ sudo apt-get autoremove 安装mysql图形化操作软件workbench。 1$ sudo apt-get install mysql-workbench Shell登录数据库，mysql -h host -u user -p。 1234# 登录远程数据库，host为IP地址$ mysql -h host -u root -p# 登录本地数据库$ mysql -u root -p 参考资料MYSQL Ubuntu wikiA Quick Guide to Using the MySQL APT RepositoryConnecting to and Disconnecting from the Server","categories":[{"name":"Databases","slug":"Databases","permalink":"http://garfieldwiki.com/categories/Databases/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://garfieldwiki.com/tags/MySQL/"}]},{"title":"Apache Http Server简单配置和使用","slug":"apache2","date":"2017-07-06T14:40:35.000Z","updated":"2019-03-24T02:03:36.681Z","comments":true,"path":"2017/07/06/apache2/","link":"","permalink":"http://garfieldwiki.com/2017/07/06/apache2/","excerpt":"目的如何在Ubuntu16.04配置和使用Apache Http Server。","text":"目的如何在Ubuntu16.04配置和使用Apache Http Server。 简介在Linux系统中，Apache是最常用的web应用服务器 内容 安装Apache Http Server，成功安装后，默认会启动服务器，端口号为80。 12$ sudo apt-get update$ sudo apt-get install apache2 默认的资源路径为/var/www/html。 Apache web server 系统安装目录/etc/apache2/。 /etc/apache2/apache2.conf 是主配置文件，它引用了所有的配置文件。 /etc/apache2/sites-available/000-default.conf可以配置资源路径。 /etc/apache2/ports.conf 设置端口号。 Apache在Ubuntu系统下的操作需要加前缀才能执行/etc/init.d/。 1234567891011121314# 查看服务器状态$ /etc/init.d/apache2 status# 启动服务器$ /etc/init.d/apache2 start# 重启服务器$ /etc/init.d/apache2 restart# 中断请求服务，停止服务器$ /etc/init.d/apache2 stop# 完成当前所有请求服务后，停止服务器$ /etc/init.d/apache2 graceful-stop# 重新加载配置文件$ /etc/init.d/apache2 reload# 和reload一样$ /etc/init.d/apache2 force-reload 参考资料Ask UbuntuApache official siteThe difference between reload and force-reload","categories":[{"name":"Server","slug":"Server","permalink":"http://garfieldwiki.com/categories/Server/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"http://garfieldwiki.com/tags/Apache/"}]},{"title":"Ubuntu Package Management","slug":"ubuntuPackageManagement","date":"2017-07-04T12:26:10.000Z","updated":"2019-03-24T02:03:36.699Z","comments":true,"path":"2017/07/04/ubuntuPackageManagement/","link":"","permalink":"http://garfieldwiki.com/2017/07/04/ubuntuPackageManagement/","excerpt":"目的如何在Ubuntu系统下进行软件管理，介绍Ubuntu常用的包管理器。","text":"目的如何在Ubuntu系统下进行软件管理，介绍Ubuntu常用的包管理器。 简介对于刚刚入门Ubuntu操作系统的同学来说，软件的管理简直是一头雾水，不像Window操作系统，Ubuntu操作系统是通过包管理器进行软件管理，大部分需要通过命令执行。以下介绍的是Ubuntu系统下常用软件管理的正确姿势。 内容大多数Unix-like系统都提供一个中央仓库,软件以包(package)的方式存放在库(repository)里面。包管理器(package management system)提供软件的安装，升级，移除，查询等工作。 Apt-get Apt-cache Apt Dpkg Synaptic Apt-getapt-get是Ubuntu最常用的命令，大部分的软件安装都是通过该命令进行，可以从远程仓库下载软件包，并且自动管理软件包的依赖关系。 系统会在本地存储中央仓库可用的软件包信息，在你开始安装包之前，最好更新这个列表，拿到最新的软件包信息。 1$ sudo apt-get update 软件包升级，在升级之前，先执行apt-get update操作，让系统知道最新的软件包信息。 1234# 仅仅升级已经安装好的包$ sudo apt-get upgrade# 不但会升级包，而且会根据新的依赖关系新增和移除相关的包$ sudo apt-get dist-upgrade 搜索软件包。 1$ apt-cache search package 查询具体软件包的详细信息。 12$ apt-cache show package$ dpkg -s package 从远程仓库下载并安装软件包。 123$ sudo apt-get install package# 安装特定版本的软件包$ sudo apt-get install package=version 有时候，你并不想直接进行包的安装，你想知道执行安装命令的过程是怎么样的。你可以使用参数-s进行模拟安装。你可以看到当前安装依赖了哪些包，而且并不需要root的权限。 1$ apt-get install -s package 只从远程仓库下载软件包。不需要root权限，下载后的位置是执行当前命令的位置。 1$ apt-get download package 卸载软件包。 1234# 卸载大部分的文件，但是会保存相关的配置文件以备下次重新安装使用$ sudo apt-get remove package# 卸载所有的文件和配置$ sudo apt-get purge package 自动删除没有被引用的软件包。 123$ sudo apt-get autoremove# 自动删除所有没有被引用的软件包以及其配置文件$ sudo apt-get --purge autoremove Aptapt集成了apt-get和apt-cache的功能，提供了更简便的命令。 apt-get/apt-cache apt apt-get update apt update apt-get upgrade apt upgrade apt-get dist-upgrade apt full-upgrade apt-cache search package apt search package apt-get install package apt install package apt-get remove package apt remove package apt-get purge package apt purge package Dpkg Ubuntu是基于Debian系统开发的，所以.deb安装包可以使用dpkg进行安装。dpkg可以安装，卸载和构建(build)软件包，但是无法自动下载软件包和处理包之间的依赖关系。 12# 安装zip包$ sudo dpkg -i zip_3.0-4_i386.deb 特别注意，dpkg并不会处理软件包之间的依赖关系，如果你所安装的包依赖了本地没有的包，那么安装就会失败。你需要执行下面的命令去安装依赖的包。 1$ sudo apt-get install -f 大多数情况并不推荐使用dpkg卸载软件包。dpkg -r zip将会移除zip软件包，但是跟zip依赖的软件包不会被卸载掉，为了保证系统一致性（consistent state），最好使用其他包管理器进行卸载。 12# 卸载zip包$ sudo dpkg -r zip Synaptic除了命令行以外，还有一款图形化操作界面。 需要使用命令行进行安装。 1$ sudo apt-get install synaptic System &gt; Administration &gt; “Synaptic Package Manager”，启动图形化界面。 参考资料Basic package managementUbuntu and debian package management essentialsPackage ManagementInstalling SoftwareSynapticHow to use Synaptic","categories":[{"name":"Linux","slug":"Linux","permalink":"http://garfieldwiki.com/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://garfieldwiki.com/tags/Ubuntu/"}]},{"title":"NGINX简单配置和使用","slug":"nginx","date":"2017-07-02T11:25:32.000Z","updated":"2019-03-24T02:03:36.693Z","comments":true,"path":"2017/07/02/nginx/","link":"","permalink":"http://garfieldwiki.com/2017/07/02/nginx/","excerpt":"目的如何在Ubuntu16.04配置和使用NGINX。","text":"目的如何在Ubuntu16.04配置和使用NGINX。 简介使用NGINX作为静态资源服务器。 内容1.安装NGINX，成功安装后，默认会启动服务器，端口号为80。12$ sudo apt-get update$ sudo apt-get install nginx 2.NGINX配置文件名默认为nginx.conf。一般放在目录/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx。 3.NGINX启动后，可以使用以下命令进行配置。1$ sudo nginx -s &apos;signal&apos; signal有以下四种操作： stop – 快速停止运行。 quit –（graceful shutdown），完成当前http服务请求后，停止运行。 reload – 修改配置文件后，需要执行这个命令才能生效。 reopen – 重新打开日志文件。 4.配置nginx.conf的根目录和端口号。1234server &#123; listen 8080; root /data/www;&#125; 参考资料Nginx Official WebsiteBeginners Guide","categories":[{"name":"Server","slug":"Server","permalink":"http://garfieldwiki.com/categories/Server/"}],"tags":[{"name":"NGINX","slug":"NGINX","permalink":"http://garfieldwiki.com/tags/NGINX/"}]},{"title":"Python3文件读写","slug":"pythonFileProcess","date":"2017-06-22T13:31:01.000Z","updated":"2019-03-24T02:03:36.695Z","comments":true,"path":"2017/06/22/pythonFileProcess/","link":"","permalink":"http://garfieldwiki.com/2017/06/22/pythonFileProcess/","excerpt":"目的使用Python3进行文件读写。","text":"目的使用Python3进行文件读写。 内容1f = open('workfile', 'w') open(filename, mode)使用该函数进行文件的读写操作。filename：该参数为文件路径。mode：可省略，表示读取文件的模式，有以下四种模式。文件中的换行符\\n或者\\r\\n将统一转为\\n。 &#39;r&#39;：该模式表示文件只读，如果mode没填写，则默认为该模式。 &#39;w&#39;：该模式表示文件只写，写入的内容将会覆盖原有的内容。 &#39;a&#39;：该模式表示文件只写，从文件原有的内容结尾写入。 &#39;r+&#39;：该模式表示文件可读可写，从文件原有的内容结尾写入。 1234&gt;&gt;&gt; with open('workfile') as f:... read_data = f.read()&gt;&gt;&gt; f.closedTrue 推荐使用with关键字使用file对象，好处是完成文本读取后自动关闭文件流，即便是读取期间出现异常也会安全关闭。比起使用try-finally，with的语法更加简洁。如果不使用with关键字，你需要使用f.close()手动关闭文件流，及时的释放系统资源。如果你不主动关闭文件流，Python的垃圾回收器最终也会帮你释放资源，只不过释放的时间不能够预知。 1234&gt;&gt;&gt; f.read()'This is the entire file.\\n'&gt;&gt;&gt; f.read()'' f.read(size)你可以设置size来读取一定长度的文本。如果缺省或为负数，将会返回文本的全部内容。如果已经读完文本，将会返回空字符串&#39;&#39;。 123456&gt;&gt;&gt; f.readline()'This is the first line of the file.\\n'&gt;&gt;&gt; f.readline()'Second line of the file\\n'&gt;&gt;&gt; f.readline()'' f.readline()只读取一行文本,并且以\\n结尾。如果已经读完文本，将会返回空字符串&#39;&#39;。 12345&gt;&gt;&gt; for line in f:... print(line, end='')...This is the first line of the file.Second line of the file 可以使用上面这个方法进行文本读取，节约内存并且高效。你也可以使用list(f)或者f.readlines()将文本一次性放到列表里面。 12&gt;&gt;&gt; f.write('This is a test\\n')15 f.write(string)将文本写入文件中，返回的值是写入文本的长度。 参考资料Reading and Writing Files","categories":[{"name":"Python","slug":"Python","permalink":"http://garfieldwiki.com/categories/Python/"}],"tags":[]},{"title":"Atom 常用插件介绍","slug":"AtomAndPlugins","date":"2017-05-22T14:36:11.000Z","updated":"2019-03-24T02:03:36.674Z","comments":true,"path":"2017/05/22/AtomAndPlugins/","link":"","permalink":"http://garfieldwiki.com/2017/05/22/AtomAndPlugins/","excerpt":"目的简单介绍如何安装Atom，以及常用插件的介绍和安装。","text":"目的简单介绍如何安装Atom，以及常用插件的介绍和安装。 简介 Windows 用户直接下载安装即可使用。 Debian Linux (Ubuntu) 仅支持64位操作系统，直接在官网下载atom-amd64.deb，并用以下命令进行安装。1$ sudo dpkg --install atom-amd64.deb 内容Script该插件允许你直接在编辑器运行你的代码，基本上覆盖了所有常用的编程语言。1$ sudo apm install script shift-ctrl-b：如果没有指定运行哪行，就会执行整个文件。 参考资料AtomScript","categories":[{"name":"Editor","slug":"Editor","permalink":"http://garfieldwiki.com/categories/Editor/"}],"tags":[{"name":"Atom","slug":"Atom","permalink":"http://garfieldwiki.com/tags/Atom/"}]},{"title":"Video.js 快速入门","slug":"videojs","date":"2017-05-21T12:21:43.000Z","updated":"2019-03-24T02:03:36.700Z","comments":true,"path":"2017/05/21/videojs/","link":"","permalink":"http://garfieldwiki.com/2017/05/21/videojs/","excerpt":"目的如何使用 Video.js 播放视频。","text":"目的如何使用 Video.js 播放视频。 简介Video.js 是一个开源的HTML视频播放器。 内容Video.js CDN你可以通过CDN加载Video.js相关的文件。12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;link href=\"http://vjs.zencdn.net/5.19.2/video-js.css\" rel=\"stylesheet\"&gt; &lt;!-- If you'd like to support IE8 --&gt; &lt;script src=\"http://vjs.zencdn.net/ie8/1.1.2/videojs-ie8.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;video id=\"my-video\" class=\"video-js\" controls preload=\"auto\" width=\"640\" height=\"264\" poster=\"MY_VIDEO_POSTER.jpg\" data-setup=\"&#123;&#125;\"&gt; &lt;source src=\"MY_VIDEO.mp4\" type='video/mp4'&gt; &lt;source src=\"MY_VIDEO.webm\" type='video/webm'&gt; &lt;p class=\"vjs-no-js\"&gt; To view this video please enable JavaScript, and consider upgrading to a web browser that &lt;a href=\"http://videojs.com/html5-video-support/\" target=\"_blank\"&gt;supports HTML5 video&lt;/a&gt; &lt;/p&gt; &lt;/video&gt; &lt;script src=\"http://vjs.zencdn.net/5.19.2/video.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Install via npm1$ npm install --save-dev video.js Install via Bower1$ bower install video.js 参考资料Video.js","categories":[{"name":"Front End","slug":"Front-End","permalink":"http://garfieldwiki.com/categories/Front-End/"}],"tags":[{"name":"Video","slug":"Video","permalink":"http://garfieldwiki.com/tags/Video/"}]},{"title":"TypeScript环境配置","slug":"TypeScriptEntrance","date":"2017-05-20T13:28:50.000Z","updated":"2019-03-24T02:03:36.679Z","comments":true,"path":"2017/05/20/TypeScriptEntrance/","link":"","permalink":"http://garfieldwiki.com/2017/05/20/TypeScriptEntrance/","excerpt":"目的如何配置TypeScript环境，以及在Ubuntu系统下配置Atom编辑器。","text":"目的如何配置TypeScript环境，以及在Ubuntu系统下配置Atom编辑器。 简介TypeScript是由Microsoft开发维护的一门免费的开源语言。该语言是JavaScript的超集，有着严格的语法格式，同时也是一门基于类的面向对象的语言。TypeScript可以被编译为JavaScript，任何存在的JavaScript程序都是合法有效的TypeScript程序。目前很多流行的库都基于该语言开发，如AngularJS, Ionic, jQuery, MongoDB和D3.js。 内容环境配置TypeScript 可以通过Node.js进行安装。1$ sudo npm install -g typescript 将TypeScript编译为JavaScript。1tsc helloworld.ts 编辑器 Visual Studio 2017 Visual Studio 2015 Visual Studio Code Sublime Text Atom Eclipse Emacs WebStorm Vim Atom 下载Atom,并用命令行进行安装,Debian Linux (Ubuntu) 仅支持64位操作系统。 1$ sudo dpkg --install atom-amd64.deb 安装 Script插件，可以在Atom编辑器通过快捷键shift-ctrl-b执行js代码。 1$ sudo apm install script 安装Atom TypeScript插件，前提是已经安装了Git。你也可以不安装，直接编辑.ts文件进行开发。 1$ sudo apm install atom-typescript 重新启动Atom,然后会提示你安装相应的依赖包，选择安装。如果没有提示，可以手动进行安装执行下面的命令。 1$ sudo apm install linter 该插件提供了以下的功能。 自动补全（Autocomplete）: ctrl+space，使用tab进行选择。 语法校验（Live error analysis） 信息提示（Type information on hover） 定位声明位置（Goto Declaration）F12。 查询引用（Find References）: shift+F12。 代码格式化（Format Code）: ctrl+alt+l。 重命名（Rename refactoring） 保存后编译（Compile on save）: 能够帮助你保存TypeScript后，自动编译为js代码，需要在tsconfig.json配置&quot;compileOnSave&quot;: true。你可以在项目根目录创建tsconfig.json,复制下面的代码。123456&#123; &quot;compileOnSave&quot;: true, &quot;compilerOptions&quot;: &#123; &quot;noImplicitAny&quot; : true &#125;&#125; 参考资料TypeScript official siteTypeScript wikipediaatom-typescripttsconfig.jsonscript","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://garfieldwiki.com/categories/JavaScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://garfieldwiki.com/tags/TypeScript/"}]},{"title":"Videogular快速入门","slug":"videogular","date":"2017-05-19T14:33:24.000Z","updated":"2019-03-24T02:03:36.700Z","comments":true,"path":"2017/05/19/videogular/","link":"","permalink":"http://garfieldwiki.com/2017/05/19/videogular/","excerpt":"目的如何使用 Videogular 播放视频。","text":"目的如何使用 Videogular 播放视频。 简介Videogular是一个基于Angular的HTML5视频播放器，同时也支持移动端应用开发，但是不支持Flash。 内容安装推荐使用Node.js和npm进行安装。1npm install videogular 同时你也可以安装额外的主题和插件。12345678npm install videogular-themes-defaultnpm install videogular-controlsnpm install videogular-bufferingnpm install videogular-overlay-playnpm install videogular-posternpm install videogular-ima-adsnpm install videogular-angularticsnpm install videogular-dash 或者你也可以使用Bower进行安装。1bower install videogular 同时你也可以安装额外的主题和插件。123456bower install videogular-controlsbower install videogular-bufferingbower install videogular-overlay-playbower install videogular-posterbower install videogular-ima-adsbower install videogular-angulartics 除此之外，你还需要安装AngularJS和AngularJS Sanitize。12bower install angularbower install angular-sanitize First blood!新建index.html文件，并且引入相关文件。新建main.js文件，放置JS代码。12345678&lt;script src=\"bower_components/angular/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/angular-sanitize/angular-sanitize.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/videogular/videogular.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/videogular-controls/vg-controls.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/videogular-overlay-play/vg-overlay-play.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/videogular-poster/vg-poster.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/videogular-buffering/vg-buffering.js\"&gt;&lt;/script&gt;&lt;script src=\"js/main.js\"&gt;&lt;/script&gt; AngularJS Code打开main.js文件，添加下面代码。12345678910111213141516171819202122232425262728293031323334'use strict';angular.module('myApp', [ \"ngSanitize\", \"com.2fdevs.videogular\", \"com.2fdevs.videogular.plugins.controls\", \"com.2fdevs.videogular.plugins.overlayplay\", \"com.2fdevs.videogular.plugins.poster\" ] ) .controller('HomeCtrl', [\"$sce\", function ($sce) &#123; this.config = &#123; sources: [ &#123;src: $sce.trustAsResourceUrl(\"http://static.videogular.com/assets/videos/videogular.mp4\"), type: \"video/mp4\"&#125;, &#123;src: $sce.trustAsResourceUrl(\"http://static.videogular.com/assets/videos/videogular.webm\"), type: \"video/webm\"&#125;, &#123;src: $sce.trustAsResourceUrl(\"http://static.videogular.com/assets/videos/videogular.ogg\"), type: \"video/ogg\"&#125; ], tracks: [ &#123; src: \"http://www.videogular.com/assets/subs/pale-blue-dot.vtt\", kind: \"subtitles\", srclang: \"en\", label: \"English\", default: \"\" &#125; ], theme: \"bower_components/videogular-themes-default/videogular.css\", plugins: &#123; poster: \"http://www.videogular.com/assets/images/videogular.png\" &#125; &#125;; &#125;] ); 创建HTML代码为了使用Videogular，你可以使用videogular标签。vg-media将会根据controller里面设置的source和tracks变量创建视频标签。1234567891011121314151617181920212223242526&lt;div ng-app=\"myApp\"&gt; &lt;div ng-controller=\"HomeCtrl as controller\" class=\"videogular-container\"&gt; &lt;videogular vg-theme=\"controller.config.theme\"&gt; &lt;vg-media vg-src=\"controller.config.sources\" vg-tracks=\"controller.config.tracks\"&gt; &lt;/vg-media&gt; &lt;vg-controls&gt; &lt;vg-play-pause-button&gt;&lt;/vg-play-pause-button&gt; &lt;vg-time-display&gt;&#123;&#123; currentTime | date:'mm:ss' &#125;&#125;&lt;/vg-time-display&gt; &lt;vg-scrub-bar&gt; &lt;vg-scrub-bar-current-time&gt;&lt;/vg-scrub-bar-current-time&gt; &lt;/vg-scrub-bar&gt; &lt;vg-time-display&gt;&#123;&#123; timeLeft | date:'mm:ss' &#125;&#125;&lt;/vg-time-display&gt; &lt;vg-volume&gt; &lt;vg-mute-button&gt;&lt;/vg-mute-button&gt; &lt;vg-volume-bar&gt;&lt;/vg-volume-bar&gt; &lt;/vg-volume&gt; &lt;vg-fullscreen-button&gt;&lt;/vg-fullscreen-button&gt; &lt;/vg-controls&gt; &lt;vg-overlay-play&gt;&lt;/vg-overlay-play&gt; &lt;vg-poster vg-url='controller.config.plugins.poster'&gt;&lt;/vg-poster&gt; &lt;/videogular&gt; &lt;/div&gt;&lt;/div&gt; 创建响应式布局以下的样式能够让你的视频保持16：9的比例。123456789101112131415161718192021222324252627.videogular-container &#123; width: 100%; height: 320px; margin: auto; overflow: hidden;&#125;@media (min-width: 1200px) &#123; .videogular-container &#123; width: 1170px; height: 658.125px; &#125;&#125;@media (min-width: 992px) and (max-width: 1199px) &#123; .videogular-container &#123; width: 940px; height: 528.75px; &#125;&#125;@media (min-width: 768px) and (max-width: 991px) &#123; .videogular-container &#123; width: 728px; height: 409.5px; &#125;&#125; 关于Videogular的基本配置就完成了。 参考资料videogular","categories":[{"name":"Front End","slug":"Front-End","permalink":"http://garfieldwiki.com/categories/Front-End/"}],"tags":[{"name":"Video","slug":"Video","permalink":"http://garfieldwiki.com/tags/Video/"}]},{"title":"Bower 快速入门","slug":"bowerEntrance","date":"2017-05-18T13:10:16.000Z","updated":"2019-03-24T02:03:36.682Z","comments":true,"path":"2017/05/18/bowerEntrance/","link":"","permalink":"http://garfieldwiki.com/2017/05/18/bowerEntrance/","excerpt":"目的本文章主要讲如何使用 Bower。","text":"目的本文章主要讲如何使用 Bower。 简介Bower 是一个前端包管理器，帮助你安装前端框架和管理框架之间的依赖，但是并不帮助你压缩代码和做其他的任务。bower.json Bower 通过这个文件记录和管理相关的包。 内容安装 Bower首先需要安装 Node 和 npm，其次还需要安装Git。1$ npm install -g bower 通过这个命令进行Bower的安装。 使用 Bower 进行包的安装1$ bower install &lt;package&gt; 通过 bower install 进行安装，安装后的文件将会在bower_components/目录下面。 &lt;package&gt; 有以下几种类型。 1$ bower install 安装所有在bower.json里面记录的包。 1$ bower install jquery 安装jquery。 1$ bower install git://github.com/user/package.git 安装github里面的包。 1$ bower install http://example.com/script.js 安装当前链接的包。 查询安装包Search package 记录和管理包1bower init 首先初始化当前项目，Bower 会在当前项目创建bower.json文件。1bower install &lt;package&gt; --save 通过--save命令记录下载过的包文件。 使用下载好的包你可以直接引用包1&lt;script src=&quot;bower_components/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; 但是推荐和其他管理工具一起使用，如Grunt, RequireJS, Yeoman等。 参考资料Bower official site","categories":[{"name":"Front End","slug":"Front-End","permalink":"http://garfieldwiki.com/categories/Front-End/"}],"tags":[{"name":"Bower","slug":"Bower","permalink":"http://garfieldwiki.com/tags/Bower/"}]},{"title":"响应式布局设计","slug":"ResponsiveWebDesign","date":"2017-05-15T02:29:40.000Z","updated":"2019-03-24T02:03:36.677Z","comments":true,"path":"2017/05/15/ResponsiveWebDesign/","link":"","permalink":"http://garfieldwiki.com/2017/05/15/ResponsiveWebDesign/","excerpt":"目的主要讲解如何设计响应式布局。","text":"目的主要讲解如何设计响应式布局。 简介随着移动互联网的快速发展以及移动终端的多样化，单一的网站界面已经不能满足当前的需要。日常使用除了个人电脑外，还有不同屏幕大小的平板和手机。响应式布局的网站设计就是为了兼容各种不同的移动终端而设计的，同一套代码，能够在不同终端里面呈现不一样的界面。目前很多前端框架都是采用这样的布局设计。 内容本文章主要分三个方面讲解如何设计响应式布局。 流式布局（Fluid Grids） 上面是常见的网页布局，有头部栏（header），左侧菜单栏（menu），主体内容（main），右侧栏（right），底部栏（footer）还有最外层有一个DIV块（container）包裹着。首先，最外层的DIV块属性是overflow:hidden，作用是将里面有float属性的DIV块包住，控制整个布局。然后，被包住的里面的DIV块都有两个相同的属性width:percentage和float:left。在流式布局的设计中，width的属性值都是用百分比例进行控制，目的是适应不同大小的屏幕的宽度。float:left可以让里面的DIV块能够像水流一样像左方向流动，如果当前位置宽度不够，当前的DIV块就会换行。 媒介查询（Media Query） @media 是CSS3的属性，该属性在响应式布局设计中非常重要。上述代码意思是，如果当前设备的宽度小于500px，那么执行里面的CSS代码。将当前浏览器宽度调整后，就会看到如下的界面显示。 元信息（Meta）最后，还要加上下面这句话。这句话就是告诉浏览器禁止当前页面进行缩放。1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 参考资料Using media queries响应式 Web 设计","categories":[{"name":"CSS","slug":"CSS","permalink":"http://garfieldwiki.com/categories/CSS/"}],"tags":[]},{"title":"混合移动应用开发(Hybrid App)","slug":"HybridAppEntrance","date":"2017-05-05T08:41:28.000Z","updated":"2019-03-24T02:03:36.676Z","comments":true,"path":"2017/05/05/HybridAppEntrance/","link":"","permalink":"http://garfieldwiki.com/2017/05/05/HybridAppEntrance/","excerpt":"目的如何使用 Apache Cordova 和 Ionic 进行移动应用开发。","text":"目的如何使用 Apache Cordova 和 Ionic 进行移动应用开发。 简介Apache Cordova是一个开源的移动应用开发框架。能够让你使用Web前端技术(HTML5，CSS3，JavaScript)开发跨平台应用，通过配置能让你在网页端调用设备的硬件资源(网络状态，感应器，相机，联系人等)。Ionic 提供了移动应用开发的前端框架，本篇章使用 Ionic v1 Framework, 该版本是基于 AngularJS v1实现。整个应用为一个单页面应用(Single Page Application)，其路由是借助 UI-Router 实现。 内容环境配置 安装 NodeJS。 安装 Cordova 和 Ionic。 1$ npm install -g cordova ionic 初始化项目,命名为 ‘myApp’。 1$ ionic start myproject --type ionic1 本地浏览器测试项目运行。 1$ ionic serve 安卓应用开发配置 配置 JDK 和 Android SDK。 配置 Gradle。 设置环境变量。 JAVA_HOME ANDROID_HOME为SDK路径。 将下面路径加入到$PATH环境变量里面。 Gradle Platform-tools Tools 添加安卓开发平台。 1Cordova platform add android --save 构建安卓项目。 1Cordova build android --verbose 电脑运行安卓虚拟机。 1Cordova run android","categories":[{"name":"Mobile","slug":"Mobile","permalink":"http://garfieldwiki.com/categories/Mobile/"}],"tags":[{"name":"Hybrid App","slug":"Hybrid-App","permalink":"http://garfieldwiki.com/tags/Hybrid-App/"}]},{"title":"JSHint 配置与使用","slug":"jsHintEntrance","date":"2017-04-19T02:51:31.000Z","updated":"2019-03-24T02:03:36.688Z","comments":true,"path":"2017/04/19/jsHintEntrance/","link":"","permalink":"http://garfieldwiki.com/2017/04/19/jsHintEntrance/","excerpt":"目的介绍什么是 JSHint，以及如何在Sublime Text中配置和使用。","text":"目的介绍什么是 JSHint，以及如何在Sublime Text中配置和使用。 简介在编写 JavaScript 的时候，JSHint 能够帮助你进行语法检查和校验，能够尽早的发现代码中出现的问题。 内容在 Sublime Text 2 和 3 中使用 JSHint Gutter 插件，该插件是基于 JSHint 进行开发的。 首先你需要安装 node.js。 通过 Sublime Package Manager 进行安装。 在编辑器里面使用快捷键 Ctrl+Shift+P。 输入 install 后，选择 Package Control: Install Package。 输入 js gutter 后，选择 JSHint Gutter即可安装。 使用方式 快捷键 Ctrl+Shift+P，然后输入 jshint。 右键选择 JSHint，点击 Lint Code。 参考资料JSHint Gutter for Sublime Text 2 and 3 via node.jsJSHint","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://garfieldwiki.com/categories/JavaScript/"}],"tags":[{"name":"JSHint","slug":"JSHint","permalink":"http://garfieldwiki.com/tags/JSHint/"}]},{"title":"Git 常用命令","slug":"GitCL","date":"2017-04-14T13:55:25.000Z","updated":"2019-03-24T02:03:36.674Z","comments":true,"path":"2017/04/14/GitCL/","link":"","permalink":"http://garfieldwiki.com/2017/04/14/GitCL/","excerpt":"目的本文章主要记录一些 Git 常用的命令行，方便开发过程中进行查阅和使用。","text":"目的本文章主要记录一些 Git 常用的命令行，方便开发过程中进行查阅和使用。 配置参数 $ git config --global user.name “[name]” 设置全局用户名 $ git config --global user.email “[email address]” 设置全局邮箱 代码库操作 $ git init [project-name] 新建代码库 $ git clone [url] 下载远程代码库 修改操作 $ git status 列出所有新建的或者修改过的文件详细信息 $ git status -s 列出所有新建的或者修改过的文件精简信息 $ git diff 查看未在缓存区的文件差异 $ git add [file] 添加新建或修改后的文件到缓存区 $ git add . 递归添加文件 $ git add * 添加同目录的所有文件 $ git diff --staged 查看已经在缓存区的文件差异 $ git reset [file] 将已缓存的文件移出缓存区 $ git commit -m “[备注信息]” 提交代码到代码库 分支操作 $ git branch 列出所有分支 $ git branch [branch-name] 创建新的分支 $ git checkout [branch-name] 切换分支 $ git merge [branch] 将某个分支合并到当前分支 $ git branch -d [branch-name] 删除分支 移动和移除文件 $ git rm [file] 删除文件 $ git rm --cached [file] 从代码库中移除文件记录，但保存本地文件 $ git mv [file-original] [file-renamed] 修改文件名 查看忽略的文件 $ git ls-files --other --ignored --exclude-standard 列出代码库中所有的忽略文件 保存当前工作环境 $ git stash 保存当前的工作环境 $ git stash pop 恢复最近保存的工作环境 $ git stash list 列出所有临时保存的记录 $ git stash drop 丢弃最近保存的工作环境 查看历史记录 $ git log 查看历史提交记录 $ git log --follow[file] 列出某个文件的所有版本历史 $ git diff [first-branch]...[second--branch] 查看两个分支的不同内容 $ git show [commit] 输出某次commit 的内容区别 切换工作环境到某个commit节点 $ git reset [commit] 将当前工作环境回滚到选中得节点，同时保留已修改的记录 $ git reset --hard [commit] 将当前工作环境回滚到选中得节点，已修改的记录全部清除 代码更新 $ git fetch [repo] 从repo库里面下载所有的历史记录，但并不和本地代码合并 $ git merge [repo] / [branch] 将repo的branch合并入当前本地branch $ git push [alias][branch] 提交当前branch代码到远程库 $ git pull 下载所有的历史记录，并和本地代码进行merge操作","categories":[{"name":"Git","slug":"Git","permalink":"http://garfieldwiki.com/categories/Git/"}],"tags":[]},{"title":"Ubuntu 实用小工具","slug":"UbuntuTips","date":"2017-04-13T14:10:37.000Z","updated":"2019-03-24T02:03:36.680Z","comments":true,"path":"2017/04/13/UbuntuTips/","link":"","permalink":"http://garfieldwiki.com/2017/04/13/UbuntuTips/","excerpt":"目的本文章主要介绍一些在 Ubuntu 操作系统里面常用的一些工具，这些工具在日常的开发和学习中，能够给你很大的便利。本系统版本为 Ubuntu 16.04 LTS 64位 英文版。","text":"目的本文章主要介绍一些在 Ubuntu 操作系统里面常用的一些工具，这些工具在日常的开发和学习中，能够给你很大的便利。本系统版本为 Ubuntu 16.04 LTS 64位 英文版。 截图工具 （ Screenshot ） 点击左侧工具栏的 Ubuntu 图标，输入 Screenshot 即可找到软件。 该工具提供了3种不同选项，抓取全屏、抓取当前窗口和随意截屏。 你也可以设置定时器，然后点击 Take Screenshot 即可截屏。 你也可以使用快捷键进行操作。 PrtSc : 抓取全屏 Alt + PrtSc : 抓取当前窗口 Shift + PrtSc : 随意截屏 远程桌面客户端 （ Remmina Remote Desktop Client ） 点击左侧工具栏的 Ubuntu 图标，输入 Remmina Remote Desktop Client 即可找到软件。 打开后，点击 New 弹出设置窗口。 设置 Name 给当前连接命名，设置连接协议 Protocol 为 SSH-Secure Shell, Server 为你的服务器IP地址，User name 为主机登录账户，选择 Password，然后点击 Connect 后输入密码即可连接到远程服务器。 左侧任务栏切换 将左侧的任务栏切换到底部，跟Window一致。 1gsettings set com.canonical.Unity.Launcher launcher-position Bottom 恢复左侧任务栏。 1gsettings set com.canonical.Unity.Launcher launcher-position Leftd","categories":[{"name":"Linux","slug":"Linux","permalink":"http://garfieldwiki.com/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://garfieldwiki.com/tags/Ubuntu/"}]},{"title":"Sass 快速入门","slug":"SassEntrance","date":"2017-04-13T08:56:54.000Z","updated":"2019-03-24T02:03:36.678Z","comments":true,"path":"2017/04/13/SassEntrance/","link":"","permalink":"http://garfieldwiki.com/2017/04/13/SassEntrance/","excerpt":"目的如何在 Linux Ubuntu 16.4 LTS 环境下安装 Sass，以及如何使用 Sass。","text":"目的如何在 Linux Ubuntu 16.4 LTS 环境下安装 Sass，以及如何使用 Sass。 准备工作 首先需要安装 Ruby, 使用 Ubuntu apt package manager 进行安装。 1$ sudo apt-get install ruby-full 安装 Sass。 1sudo gem install sass 安装成功后，查看 Sass 版本号，当前使用版本为 Sass 3.4.23 。 1sass -v 简介Sass 其实是 CSS 的预编译器，主要对 CSS 进行预编译。Sass 会让CSS的编写变得更加简便，能够更好得进行维护，它为 CSS 提供了语法特性：变量（variables），嵌套（nesting），mixins，继承 (inheritance)等。 内容预编译 1sass input.scss output.css input.scss 是你编写的 Sass 文件，output.css 是编译后的 CSS 文件。 Sass 有两种格式，一种为 .sass, 另一种为 .scss，后者格式跟 CSS 一样，这里使用后者的格式进行讲解。 变量（Variables）Sass 使用美元符号 $ 进行变量的声明。 Sass 源代码：1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 编译后代码：1234body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125; 嵌套 (Nesting)Sass 源代码：123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 编译后代码：123456789101112131415nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; Partials为了方便代码维护，你可以将你得代码模块化。创建一个文件_partial.scss，文件需要用下划线开头，这样做的目的是告诉Sass你这个文件只是一个模块文件，并且Sass不会去编译这个文件。只有在其他文件使用@import把当前的文件导入后，会自动将文件编译到目标文件里面。 导入（Import）CSS 同样也有导入功能，可以让你的代码精简并且更好维护。唯一的缺点就是每次使用 @import的时候都需要创建http请求。Sass 在此基础之上克服了这个缺点，它会在编译的时候，把引用的代码合并到目标文件。下面有两个文件，目的是把_reset.scss 合并到base.scss。 Sass 源代码：123456789101112131415161718// \\_reset.scsshtml,body,ul,ol &#123; margin: 0; padding: 0;&#125;// base.scss@import 'reset';body &#123; font: 100% Helvetica, sans-serif; background-color: #efefef;&#125; 你可以看到我们使用 @import &#39;reset&#39; 的时候，并没有加上下划线和后缀名，因为Sass会自动进行识别。 编译后代码：123456789html, body, ul, ol &#123; margin: 0; padding: 0;&#125;body &#123; font: 100% Helvetica, sans-serif; background-color: #efefef;&#125; Mixins这个功能方便你重用代码块，你也可以传递参数给你的代码块。使用@mixin进行声明代码块，使用$radius声明参数，使用@include进行引用。 Sass 源代码：12345678@mixin border-radius($radius) &#123; -webkit-border-radius: $radius; -moz-border-radius: $radius; -ms-border-radius: $radius; border-radius: $radius;&#125;.box &#123; @include border-radius(10px); &#125; 编译后代码：123456.box &#123; -webkit-border-radius: 10px; -moz-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; 继承（Extend/Inheritance）@extend 能够让你的代码进行继承。 Sass 源代码：1234567891011121314151617181920.message &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; @extend .message; border-color: green;&#125;.error &#123; @extend .message; border-color: red;&#125;.warning &#123; @extend .message; border-color: yellow;&#125; 编译后代码：1234567891011121314151617.message, .success, .error, .warning &#123; border: 1px solid #cccccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125;.error &#123; border-color: red;&#125;.warning &#123; border-color: yellow;&#125; 运算符（Operators）Sass 支持 +, -, *, /, % 运算。 Sass 源代码：1234567891011.container &#123; width: 100%; &#125;article[role=\"main\"] &#123; float: left; width: 600px / 960px * 100%;&#125;aside[role=\"complementary\"] &#123; float: right; width: 300px / 960px * 100%;&#125; 编译后代码：12345678910111213.container &#123; width: 100%;&#125;article[role=\"main\"] &#123; float: left; width: 62.5%;&#125;aside[role=\"complementary\"] &#123; float: right; width: 31.25%;&#125; 常用命令监听单个文件1sass --watch style.scss:style.css 监听文件夹1sass --watch sassFileDirectory:cssFileDirectory css文件转成sass/scss文件12sass-convert style.css style.sasssass-convert style.css style.scss 编译后的css格式有四种取值：nested，expanded，compact，compressed1sass --watch style.scss:style.css --style compact 参考资料Sass official guide","categories":[{"name":"CSS","slug":"CSS","permalink":"http://garfieldwiki.com/categories/CSS/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"http://garfieldwiki.com/tags/SASS/"}]},{"title":"Http 缓存","slug":"HttpCaching","date":"2017-04-10T03:14:00.000Z","updated":"2019-03-24T02:03:36.675Z","comments":true,"path":"2017/04/10/HttpCaching/","link":"","permalink":"http://garfieldwiki.com/2017/04/10/HttpCaching/","excerpt":"目的理解什么是 Http 缓存。","text":"目的理解什么是 Http 缓存。 简介在 Web 应用开发中，用户对网页的响应速度要求极高。如果每次刷新页面都要从服务器里面重新拿网页资源（HTML, CSS, Javascript, Image, Video, etc），不仅会影响网页的响应速度，而且也很占用服务器宝贵的带宽资源。 为了解决上述的问题，可以设置 Http 缓存（Http Caching）。在一定的条件范围内，用户重新访问相同的网页资源，只需在浏览器缓存中提取即可，并不需要从服务器中重新获取资源。目前所有的现代浏览器都实现了 Http 缓存，你只需要在服务器响应（Response）中设置 Http 协议头 ( Http header) 的参数，确保服务器正确的返回响应的参数。在设置缓存的同时，也要注意怎么处理缓存过期，避免用户看到过期的内容。 内容有以下两种设置方式，HTTP cache headers 和 Conditional requests，它们的区别是后者加载资源的时候，会和服务器进行一次请求，如果请求的资源有更新，就重新去服务器加载资源，否则从本地缓存中加载资源，而前者不用和服务器进行请求，只是告诉浏览器怎么加载本地缓存。 HTTP cache headers:Http 协议头有两个重要的参数设置 Cache-Control 和 Expires 。 Cache-Control ：在设置 Http 缓存的时候，一定要在协议头里面加上 Cache-Control 属性，否则对其他协议头（caching headers）的设置都不会生效。 Public ： 表示不仅在用户浏览器端进行缓存，而且在中转代理服务器中（intermediate proxies）也进行缓存。Cache-Control:public Privete ： 表示只在用户浏览器端进行缓存，一般涉及到用户个人隐私数据的时候使用。Cache-Control:private max-age : 设置缓存时间长度，单位为秒。Cache-Control:public, max-age=30当前设置是30秒后过期，需要重新去服务器请求资源。 Expires ： 这个属性是给缓存指定一个过期的时间点，如果超过当前时间点，需要重新去服务器加载资源。如果 Expires 和 max-age 同时设置，max-age 的优先级更高。Cache-Control:publicExpires: Mon, 25 Jun 2012 21:31:12 GMT Conditional requests :Conditional requests 其实就是每次加载资源的时候，都会去服务器询问当前资源是否有更新，如果有，就返回最新的资源。如果没有，就返回 Http 状态码304。虽然每次加载资源都需要请求服务器，但是只要资源没有更新，返回的 response body 是空的，这样也就减轻的带宽的压力，同时也避免用户浏览器缓存更新不及时，看到过期内容的情况。 Time-based : 基于时间的设置 Last-Modified ：在第一次加载资源的时候，给当前资源标记最新的时间戳。Cache-Control:public, max-age=30Last-Modified: Mon, 03 Jan 2011 17:45:57 GMT 重新加载资源的时候，浏览器自动会发送缓存资源的时间戳给服务器。If-Modified-Since: Mon, 03 Jan 2011 17:45:57 GMT如果在 Mon, 03 Jan 2011 17:45:57 GMT 之前，资源都没有更新，服务器会返回 304 状态码和空的响应体（empty response body）。 Content-based ：基于内容的设置 ETag (or Entity Tag) ：类似 Last-Modified ，但是它的值是一组字符串（类似 MD5 hash），其实就是给服务器进行校验两个文件是否相同的文件校验码（checksum）。Cache-Control:public, max-age=30ETag: &quot;15f0fff99ed5aae4edffdd6496d7131f&quot; 重新加载资源的时候，浏览器自动会发送文件校验码给服务器。If-None-Match: &quot;15f0fff99ed5aae4edffdd6496d7131f&quot;服务器检测到两个校验码相同，表示当前资源没有更新，服务器会返回 304 状态码和空的响应体（empty response body）。 实践参考静态资源缓存在网站应用中，如果某些资源（Image，CSS，JavaScript，etc）在可预见的未来不会被更新，建议将 max-age 设置为1年（1年大概有31536000秒） ，并且设置1年后的 Expires 时间点。不建议把时间设置超过1年，参考RFC。Cache-Control:public; max-age=31536000Expires: Mon, 25 Jun 2013 21:31:12 GMT 停用缓存对于一些资源需要每次都从服务器加载的，或者一些敏感的个人数据不方便缓存的，建议明确的设置缓存停用。因为基于各种不同浏览器的内部实现，很可能会自动帮你做了缓存处理。Cache-Control:no-cache, no-store, must-revalidate ETag VS Cache-control Header or Expires如果仅仅设置Etag，每次页面刷新都会重新对服务器进行请求。ETag 仅仅是为了校验文件是否更新。ETag: &quot;15f0fff99ed5aae4edffdd6496d7131f&quot; 如果设置了max-age，那么在有效期30秒内，浏览器都只从本地缓存中加载资源，不会去请求服务器。Cache-Control:public, max-age=30ETag: &quot;15f0fff99ed5aae4edffdd6496d7131f&quot; 组合实现假设一个情况，一个 CSS 文件你设置了缓存时间为24小时 (max-age=86400)，但是你发现里面有问题，马上进行了修改并且上线，但是客户端并不能马上进行缓存更新，这种情况怎么办？如何能够做到客户端能够长时间的缓存，但是又能够马上进行缓存的更新呢？ 你可以通过修改 URL 强制用户重新加载资源，类似Etage文件校验码的原理，你可以把校验码放在文件名中，比如 style.x234dff.css。HTML 里面 Cache-Control 设置为 “no-cache”，目的就是让浏览器每次都到服务器拿到最新的代码。通过组合 Etage，Cache-Control 和 URLs，不但能够拥有长时间的缓存，又能够满足对文件修改并及时生效的需求。 参考资料Increasing Application Performance with HTTP Cache HeadersMozilla : HTTP cachingGoogle : HTTP CachingHow To Optimize Your Site With HTTP CachingETag vs Header Expires","categories":[{"name":"Network","slug":"Network","permalink":"http://garfieldwiki.com/categories/Network/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://garfieldwiki.com/tags/Http/"}]},{"title":"Sahi 快速入门","slug":"SahiEntrance","date":"2017-03-23T09:27:07.000Z","updated":"2019-03-24T02:03:36.678Z","comments":true,"path":"2017/03/23/SahiEntrance/","link":"","permalink":"http://garfieldwiki.com/2017/03/23/SahiEntrance/","excerpt":"目的使用 Sahi Pro 进行自动化测试。","text":"目的使用 Sahi Pro 进行自动化测试。 准备工作 需要 Java 环境1.5版本以上。 在 Sahi 官网下载安装包。 安装 SahiSahi 的安装包为 jar 包，双击安装包 install_sahi_pro_xxx.jar 进行安装。 启动 Sahi 监控台双击桌面快捷键就可以打开 Sahi 监控台。 通过 Sahi 录制脚本 在监控台里面选择一个浏览器，打开浏览器，这里选择 Google Chrome。 你可以在浏览器里面点击 Sahi Controller 打开控制面板，或者使用快捷键：按住ATL键后鼠标左键双击浏览器也能打开控制面板。 选择控制面板的 Record ，打开录制标签页。 在 Script Name 里面输入 first_script.sah 作为录制脚本名，点击 Record。 在浏览器里面点击 “Sample Application”，你就会打开 Sahi 自带的测试应用。 输入 username 为 “test”，password 为 “secret”，点击 “Login”。在 “Evaluate Expression” 框里面，你可以看到被记录的最后一步。 在新的页面里面，展示的是一个购物车场景，在 “Add quantity to cart” 里面分别输入2,3,1 ，然后点击 “Add”。 添加断言（assertions）一个脚本通常由2部分组成：网页的操作过程和操作过程的校验，对于校验，Sahi 使用断言。Sahi 允许在录制脚本的过程中添加断言。 按住 “CTRL” 键，在网页里面移动鼠标去定位网页元素。 首先我们先把鼠标移动到 “Grand Total” 的输入框，在录制标签页里面，你可以看到 “Accessor” 会拿到当前鼠标定位的网页元素路径。 点击 “Assert” 按钮为当前元素添加断言。 你可以在 “Evaluate Expression” 里面看到程序自动生成的断言。 点击 “Test–&gt;”，可以看到测试结果为 true。 如果没有问题，你可以点击 “Append to Script”，将断言添加到你的脚本里面去。 点击 “Logout” 退出当前应用。 在控制面板里面点击 “Stop” 结束脚本录制。 回放脚本 打开 “Playback” 标签页，在 “File” 里面输入你的脚本名字 “first_script.sah”。 输入初始URL，这里为 “ http://sahi.co.in/demo/training/login.html ” 。 点击 “Play” 开始执行录制的脚本。 脚本结束后会在下面显示执行的结果 SUCCESS 或者 FAILURE 。 查看日志在控制面板的回放标签页下面，点击 “Logs”，可以查看所有脚本跑完后的结果。","categories":[{"name":"Testing","slug":"Testing","permalink":"http://garfieldwiki.com/categories/Testing/"}],"tags":[{"name":"Sahi","slug":"Sahi","permalink":"http://garfieldwiki.com/tags/Sahi/"}]},{"title":"基于角色的权限管理","slug":"Role-based-Access-Control","date":"2017-03-20T06:26:14.000Z","updated":"2019-03-24T02:03:36.677Z","comments":true,"path":"2017/03/20/Role-based-Access-Control/","link":"","permalink":"http://garfieldwiki.com/2017/03/20/Role-based-Access-Control/","excerpt":"目的理解什么是基于角色的权限管理（RBAC）？","text":"目的理解什么是基于角色的权限管理（RBAC）？ 简介目前单系统应用中，基于角色的权限管理 (Role-based Access Control) 被奉为是最佳实践。 在系统应用中，最核心的是业务的数据和对数据的操作，其次最重要的是系统应该辨别哪些用户可以访问数据和对数据能进行什么操作。后者其实就是所谓的权限管理，权限管理包括认证和授权。认证就是对用户进行识别，看该用户是不是合法用户，只有合法用户才能够进入系统。授权就是在认证的基础之上，管理用户可以访问哪些数据和对数据的增删查改 (CRUD)。 内容基于角色的权限管理实际上是处理主体（Subject），角色（Role），权限（Permission）三者之间的关系。 Subject：指调用本系统服务的“用户”，可以是具体的某个人也可以是其他系统。 Role：比如系统管理员，公司普通职员或者经理。 Permission：比如财务经理可以看到所有员工的薪资，但是普通用户只能看到自己的薪资。 在设计系统架构中，需要考虑三个层面的设计： 核心架构 角色的继承 职责分离 核心架构通常一个机构都会给每个人分配不同的职位，不同职位有不同的工作范围。职位其实就是角色，工作范围也代表了你的操作权限。如图 RBAC01 所示，主体，角色和权限其实是多对多的关系。 不同的职位代表了不同的操作权限。 角色的继承通常来说，角色是有继承关系的，比如一个部门经理的权限是包含了该部门普通员工的权限。 举个栗子，在一个软件部门里面，某个人被分配到该部门，他有进入该部门的最低权限，然后他被分配到 TeamOne 做开发，那么他就有该小组的权限和做开发的权限。在该部门里面，Manager有该部门的所有的权限。 职责分离职责分离（Separation of duties）其实就是在用户和角色之间加一层约束。简单的说，就是在同一个球场上，不会有一个人既是球员又是裁判。 使用场景 在单系统应用中，广泛的被业界所接受，被列为最佳实践。 比较适合角色稳定并且角色数量有限的应用。 优点 批量授权：只要给某个角色赋予对应的权限，就可以批量的授权给对应的用户。 能够迅速变更权限：能够快速的变更某个人的角色，比如某员工离职或升职都可以快速的移除或更换对应的角色。 缺点 需要有人一直去维护主体，角色和权限的关系，直到该系统下线。 所有的用户都至少有一个角色。 给某个用户授权的时候，都需要有另一个人去审核该用户所对应的角色没有越权。 参考资料Wikipedia: Role-based access controlBeyond Roles: A Practical Approach to Enterprise User ProvisioningRole Based Access Control (RBAC) and Role Based Security","categories":[{"name":"Security","slug":"Security","permalink":"http://garfieldwiki.com/categories/Security/"}],"tags":[{"name":"RBAC","slug":"RBAC","permalink":"http://garfieldwiki.com/tags/RBAC/"}]}]}